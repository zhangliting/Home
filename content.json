{"meta":{"title":"Hello World","subtitle":"zhangliting's blog","description":"A blog of Zhang Liting","author":"Zhang Liting","url":"http://zhangliting.github.io"},"pages":[{"title":"","date":"2017-04-17T16:53:56.779Z","updated":"2017-04-17T16:53:56.000Z","comments":true,"path":"404.html","permalink":"http://zhangliting.github.io/404.html","excerpt":"","text":"404 *{margin:0;padding:0;outline:none;font-family:\\5FAE\\8F6F\\96C5\\9ED1,宋体;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;-khtml-user-select:none;user-select:none;cursor:default;font-weight:lighter;} .center{margin:0 auto;} .whole{width:100%;height:100%;line-height:100%;position:fixed;bottom:0;left:0;z-index:-1000;overflow:hidden;} .whole img{width:100%;height:100%;} .mask{width:100%;height:100%;position:absolute;top:0;left:0;background:#000;opacity:0.6;filter:alpha(opacity=60);} .b{width:100%;text-align:center;height:400px;position:absolute;top:50%;margin-top:-230px}.a{width:150px;height:50px;margin-top:30px}.a a{display:block;float:left;width:150px;height:50px;background:#fff;text-align:center;line-height:50px;font-size:18px;border-radius:25px;color:#333}.a a:hover{color:#000;box-shadow:#fff 0 0 20px} p{color:#fff;margin-top:40px;font-size:24px;} #num{margin:0 5px;font-weight:bold;} var num=4; function redirect(){ num--; document.getElementById(\"num\").innerHTML=num; if(num"},{"title":"tags","date":"2017-04-17T16:45:17.000Z","updated":"2017-04-17T16:55:19.000Z","comments":false,"path":"tags/index.html","permalink":"http://zhangliting.github.io/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2017-04-17T16:45:31.000Z","updated":"2017-04-17T16:55:25.000Z","comments":false,"path":"categories/index.html","permalink":"http://zhangliting.github.io/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2017-04-17T16:53:03.000Z","updated":"2017-04-17T16:53:03.621Z","comments":true,"path":"about/index.html","permalink":"http://zhangliting.github.io/about/index.html","excerpt":"","text":""}],"posts":[{"title":"Java 8 多线程基础","slug":"Java-8-多线程基础","date":"2017-04-24T13:04:32.000Z","updated":"2017-04-24T13:05:59.000Z","comments":true,"path":"2017/04/24/Java-8-多线程基础/","link":"","permalink":"http://zhangliting.github.io/2017/04/24/Java-8-多线程基础/","excerpt":"Java Concurrency API 从Java 5开始引入，到现在做了很多改进。 Part 1: Threads and Executors现在操作系统通过进程和线程实现并发。进程拥有独立的资源，一个进程中可有创建多个线程，折线线程共享进程的资源。 Thread1234567891011Runnable task = () -&gt; &#123; String threadName = Thread.currentThread().getName(); System.out.println(\"Hello \" + threadName);&#125;;task.run();Thread thread = new Thread(task);thread.start();System.out.println(\"Done!\"); output123Hello mainHello Thread-0Done! 线程可以sleep1TimeUnit.SECONDS.sleep(1);//暂停1秒","text":"Java Concurrency API 从Java 5开始引入，到现在做了很多改进。 Part 1: Threads and Executors现在操作系统通过进程和线程实现并发。进程拥有独立的资源，一个进程中可有创建多个线程，折线线程共享进程的资源。 Thread1234567891011Runnable task = () -&gt; &#123; String threadName = Thread.currentThread().getName(); System.out.println(\"Hello \" + threadName);&#125;;task.run();Thread thread = new Thread(task);thread.start();System.out.println(\"Done!\"); output123Hello mainHello Thread-0Done! 线程可以sleep1TimeUnit.SECONDS.sleep(1);//暂停1秒 ExecutorsJava Concurrency API 引入ExecutorService作为一个更高级的创建线程的方法。`Executors可以创建能够运行异步任务的线程池。所有我们不需要手动创建线程了。线程池中的线程可以重复使用。 example1234567ExecutorService executor = Executors.newSingleThreadExecutor();//只有一个线程的池executor.submit(() -&gt; &#123; String threadName = Thread.currentThread().getName(); System.out.println(\"Hello \" + threadName);&#125;);// =&gt; Hello pool-1-thread-1 线程池并不会自己关闭。ExecutorService提供两个方法：shutdown():等待当前运行的线程结束。shutdownNow():立即中断所有线程并关闭线程池。 123456789101112131415try &#123; System.out.println(\"attempt to shutdown executor\"); executor.shutdown(); executor.awaitTermination(5, TimeUnit.SECONDS);&#125;catch (InterruptedException e) &#123; System.err.println(\"tasks interrupted\");&#125;finally &#123; if (!executor.isTerminated()) &#123; System.err.println(\"cancel non-finished tasks\"); &#125; executor.shutdownNow(); System.out.println(\"shutdown finished\");&#125; Callables and FuturesCallable的功能和Runnable一样，只是有返回值。123456789Callable&lt;Integer&gt; task = () -&gt; &#123; try &#123; TimeUnit.SECONDS.sleep(1); return 123; &#125; catch (InterruptedException e) &#123; throw new IllegalStateException(\"task interrupted\", e); &#125;&#125;; Callable也可以使用ExecutorService提交，但是必须使用Future接受返回值。 123456789ExecutorService executor = Executors.newFixedThreadPool(1);Future&lt;Integer&gt; future = executor.submit(task);System.out.println(\"future done? \" + future.isDone());Integer result = future.get();System.out.println(\"future done? \" + future.isDone());System.out.print(\"result: \" + result); output:123future done? falsefuture done? trueresult: 123 调用futer.get()方法会阻塞，直到callable结束。为了防止因为阻塞而失去响应，我们可以使用Timeout。 12345678910111213ExecutorService executor = Executors.newFixedThreadPool(1);Future&lt;Integer&gt; future = executor.submit(() -&gt; &#123; try &#123; TimeUnit.SECONDS.sleep(2);//等待2秒 return 123; &#125; catch (InterruptedException e) &#123; throw new IllegalStateException(\"task interrupted\", e); &#125;&#125;);future.get(1, TimeUnit.SECONDS);//等待1秒 超时会抛出异常+12Exception in thread \"main\" java.util.concurrent.TimeoutException at java.util.concurrent.FutureTask.get(FutureTask.java:205) Executors支持使用invokeAll(),支持批量提交callable任务。123456789101112131415161718ExecutorService executor = Executors.newWorkStealingPool();List&lt;Callable&lt;String&gt;&gt; callables = Arrays.asList( () -&gt; \"task1\", () -&gt; \"task2\", () -&gt; \"task3\");executor.invokeAll(callables) .stream() .map(future -&gt; &#123; try &#123; return future.get(); &#125; catch (Exception e) &#123; throw new IllegalStateException(e); &#125; &#125;) .forEach(System.out::println); invokeAny() 返回最先执行Callable的值。123456789101112131415161718Callable&lt;String&gt; callable(String result, long sleepSeconds) &#123; return () -&gt; &#123; TimeUnit.SECONDS.sleep(sleepSeconds); return result; &#125;;&#125;ExecutorService executor = Executors.newWorkStealingPool();List&lt;Callable&lt;String&gt;&gt; callables = Arrays.asList( callable(\"task1\", 2), callable(\"task2\", 1), callable(\"task3\", 3));String result = executor.invokeAny(callables);System.out.println(result);// =&gt; task2 newWorkStealingPool()使用了ForkJoinPools，默认的并行数=CPU的核数。 Scheduled ExecutorsScheduledExecutorService可以定时运行任务。 example12345678910ScheduledExecutorService executor = Executors.newScheduledThreadPool(1);Runnable task = () -&gt; System.out.println(\"Scheduling: \" + System.nanoTime());//延迟3秒执行ScheduledFuture&lt;?&gt; future = executor.schedule(task, 3, TimeUnit.SECONDS);TimeUnit.MILLISECONDS.sleep(1337);long remainingDelay = future.getDelay(TimeUnit.MILLISECONDS);System.out.printf(\"Remaining Delay: %sms\", remainingDelay); scheduleAtFixedRate() 和 scheduledWidhtFixedDelay()1234567ScheduledExecutorService executor = Executors.newScheduledThreadPool(1);Runnable task = () -&gt; System.out.println(\"Scheduling: \" + System.nanoTime());int initialDelay = 0;int period = 1;executor.scheduleAtFixedRate(task, initialDelay, period, TimeUnit.SECONDS); scheduleAtFixedRate()的时间间隔并不会包括任务执行的时间。scheduleWithFixedDelay()的时间间隔是上一次结束时间到下一次开始时间的间隔。适合你无法估计任务运行的时间，但是又希望间相同的时间进行。 Part 2 Synchronization and Locks以下可能使用到的stop()和sleep()的方法定义：123456789101112131415161718192021222324252627public class ConcurrentUtils &#123; public static void stop(ExecutorService executor) &#123; try &#123; executor.shutdown(); executor.awaitTermination(60, TimeUnit.SECONDS); &#125; catch (InterruptedException e) &#123; System.err.println(\"termination interrupted\"); &#125; finally &#123; if (!executor.isTerminated()) &#123; System.err.println(\"killing non-finished tasks\"); &#125; executor.shutdownNow(); &#125; &#125; public static void sleep(int seconds) &#123; try &#123; TimeUnit.SECONDS.sleep(seconds); &#125; catch (InterruptedException e) &#123; throw new IllegalStateException(e); &#125; &#125;&#125; Synchronized定义给一个increment()方法，我们需要多个线程同时访问它。12345int count = 0;void increment() &#123; count = count + 1;&#125; 12345678ExecutorService executor = Executors.newFixedThreadPool(2);IntStream.range(0, 10000) .forEach(i -&gt; executor.submit(this::increment));stop(executor);System.out.println(count); // 9965 increment()操作需要三步： 读取变量 增加1 写回变量 所以我们需要互斥访问这个方法，使用synchronized 同步方法。 123synchronized void incrementSync() &#123; count = count + 1;&#125; 或者 同步块12345void incrementSync() &#123; synchronized (this) &#123; count = count + 1; &#125;&#125; synchronized内部实现是通过monitor，每一个对象都有monitor，多个线程访问同一个对象需要获得monitor。这也解释了可重入锁（同步方法调用另一个同步方法，使用同一个对象锁）的原因，一个线程可以安全的多次获取同一把锁。 LocksReentrantLock (重入锁)可重入锁与synchronized一样可以实现资源的互斥访问。 1234567891011ReentrantLock lock = new ReentrantLock();int count = 0;void increment() &#123; lock.lock(); try &#123; count++; &#125; finally &#123; lock.unlock(); &#125;&#125; ReadWriteLock(读写锁)多个线程同时读不需要加锁，基于一般读的频率大于写的频率，可以提高性能。12345678910111213ExecutorService executor = Executors.newFixedThreadPool(2);Map&lt;String, String&gt; map = new HashMap&lt;&gt;();ReadWriteLock lock = new ReentrantReadWriteLock();executor.submit(() -&gt; &#123; lock.writeLock().lock(); try &#123; sleep(1); map.put(\"foo\", \"bar\"); &#125; finally &#123; lock.writeLock().unlock(); &#125;&#125;); 1234567891011121314Runnable readTask = () -&gt; &#123; lock.readLock().lock(); try &#123; System.out.println(map.get(\"foo\")); sleep(1); &#125; finally &#123; lock.readLock().unlock(); &#125;&#125;;executor.submit(readTask);executor.submit(readTask);stop(executor); 执行上面的代码，两个读线程必须等待写线程释放写锁，才能执行。这两个读线程是同时执行的，因为资源没有写锁，读锁就可以安全的获得。 Semaphores锁用于互斥访问资源或变量，信号量是一个允许访问的集合。123456789101112131415161718192021222324252627ExecutorService executor = Executors.newFixedThreadPool(10);Semaphore semaphore = new Semaphore(5);Runnable longRunningTask = () -&gt; &#123; boolean permit = false; try &#123; permit = semaphore.tryAcquire(1, TimeUnit.SECONDS); if (permit) &#123; System.out.println(\"Semaphore acquired\"); sleep(5); &#125; else &#123; System.out.println(\"Could not acquire semaphore\"); &#125; &#125; catch (InterruptedException e) &#123; throw new IllegalStateException(e); &#125; finally &#123; if (permit) &#123; semaphore.release(); &#125; &#125;&#125;IntStream.range(0, 10) .forEach(i -&gt; executor.submit(longRunningTask));stop(executor); output:12345678910Semaphore acquiredSemaphore acquiredSemaphore acquiredSemaphore acquiredSemaphore acquiredCould not acquire semaphoreCould not acquire semaphoreCould not acquire semaphoreCould not acquire semaphoreCould not acquire semaphore Part 3 Atomic Variables and ConcurrentMapAtomicIntegerjava.concurrent.atomic包含了很多有用的原子操作。原子级的操作不需要使用synchronized或Lock就可以并发访问。原子级操作内部的实现是compare-an-swap(CAS)，现代CPU大多都支持CAS的原子级指令。这些指令比synchronizing和Lock都要高效。当需要并发频繁修改一个变量时，推荐使用原子操作。 incrementAndGet12345678910AtomicInteger atomicInt = new AtomicInteger(0);ExecutorService executor = Executors.newFixedThreadPool(2);IntStream.range(0, 1000) .forEach(i -&gt; executor.submit(atomicInt::incrementAndGet));stop(executor);System.out.println(atomicInt.get()); // =&gt; 1000 updateAndGet1234567891011121314AtomicInteger atomicInt = new AtomicInteger(0);ExecutorService executor = Executors.newFixedThreadPool(2);IntStream.range(0, 1000) .forEach(i -&gt; &#123; Runnable task = () -&gt; atomicInt.updateAndGet(n -&gt; n + 2); executor.submit(task); &#125;);stop(executor);System.out.println(atomicInt.get()); // =&gt; 2000 accumulateAndGet1234567891011121314AtomicInteger atomicInt = new AtomicInteger(0);ExecutorService executor = Executors.newFixedThreadPool(2);IntStream.range(0, 1000) .forEach(i -&gt; &#123; Runnable task = () -&gt; atomicInt.accumulateAndGet(i, (n, m) -&gt; n + m); executor.submit(task); &#125;);stop(executor);System.out.println(atomicInt.get()); // =&gt; 499500 其他原子类AtomicBoolean AtomicLong AtomicReference ConcurrentMapexample12345ConcurrentMap&lt;String, String&gt; map = new ConcurrentHashMap&lt;&gt;();map.put(\"foo\", \"bar\");map.put(\"han\", \"solo\");map.put(\"r2\", \"d2\");map.put(\"c3\", \"p0\"); 12345678910111213141516map.forEach((key, value) -&gt; System.out.printf(\"%s = %s\\n\", key, value));String value = map.putIfAbsent(\"c3\", \"p1\");System.out.println(value); // p0String value = map.getOrDefault(\"hi\", \"there\");System.out.println(value); // theremap.replaceAll((key, value) -&gt; \"r2\".equals(key) ? \"d3\" : value);System.out.println(map.get(\"r2\")); // d3map.compute(\"foo\", (key, value) -&gt; value + value);System.out.println(map.get(\"foo\")); // barbarmap.merge(\"foo\", \"boo\", (oldVal, newVal) -&gt; newVal + \" was \" + oldVal);System.out.println(map.get(\"foo\")); // boo was foo ConcurrentHashMap使用ForkJoinPool实现并发。并发的数量取决于CPU的内核数。1System.out.println(ForkJoinPool.getCommonPoolParallelism()); // 3 可以修改JVM参数1-Djava.util.concurrent.ForkJoinPool.common.parallelism=5 map.search()12345678910111213String result = map.search(1, (key, value) -&gt; &#123; System.out.println(Thread.currentThread().getName()); if (\"foo\".equals(key)) &#123; return value; &#125; return null;&#125;);System.out.println(\"Result: \" + result);// ForkJoinPool.commonPool-worker-2// main// ForkJoinPool.commonPool-worker-3// Result: bar map.redue()1234567891011121314151617181920String result = map.reduce(1, (key, value) -&gt; &#123; System.out.println(\"Transform: \" + Thread.currentThread().getName()); return key + \"=\" + value; &#125;, (s1, s2) -&gt; &#123; System.out.println(\"Reduce: \" + Thread.currentThread().getName()); return s1 + \", \" + s2; &#125;);System.out.println(\"Result: \" + result);// Transform: ForkJoinPool.commonPool-worker-2// Transform: main// Transform: ForkJoinPool.commonPool-worker-3// Reduce: ForkJoinPool.commonPool-worker-3// Transform: main// Reduce: main// Reduce: main// Result: r2=d2, c3=p0, han=solo, foo=bar 英文原文：Java 8 Concurrency Tutorial","categories":[{"name":"Java","slug":"Java","permalink":"http://zhangliting.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://zhangliting.github.io/tags/Java/"}]},{"title":"Java 8 奇淫异巧","slug":"Java-8-奇淫异巧","date":"2017-04-24T13:03:13.000Z","updated":"2017-04-24T13:04:11.000Z","comments":true,"path":"2017/04/24/Java-8-奇淫异巧/","link":"","permalink":"http://zhangliting.github.io/2017/04/24/Java-8-奇淫异巧/","excerpt":"字符串连接字符串12String.join(\":\", \"foobar\", \"foo\", \"bar\");// =&gt; foobar:foo:bar 使用正则表达式过滤12345Pattern pattern = Pattern.compile(\".*@gmail\\\\.com\");Stream.of(\"bob@gmail.com\", \"alice@hotmail.com\") .filter(pattern.asPredicate()) .count();// =&gt;","text":"字符串连接字符串12String.join(\":\", \"foobar\", \"foo\", \"bar\");// =&gt; foobar:foo:bar 使用正则表达式过滤12345Pattern pattern = Pattern.compile(\".*@gmail\\\\.com\");Stream.of(\"bob@gmail.com\", \"alice@hotmail.com\") .filter(pattern.asPredicate()) .count();// =&gt; 数字Java的Integer是带符号的。所以范围-2^31 ~ 2^31-1Java8之前超过这个范围会抛出异常123456try &#123; Integer.parseInt(string, 10);&#125;catch (NumberFormatException e) &#123; System.err.println(\"could not parse signed int of \" + maxUnsignedInt);&#125; Java 8 Integer 可以保存无符号的整型，但是必须通过toUnsignedString才能看到正确的指。1234long maxUnsignedInt = (1l &lt;&lt; 32) - 1;//4294967295String string = String.valueOf(maxUnsignedInt);int unsignedInt = Integer.parseUnsignedInt(string, 10);//-1String string2 = Integer.toUnsignedString(unsignedInt, 10);//4294967295 数学运算Java 8增加了基本运算的Exact()方法。当运算溢出时，抛出异常。 普通加法12System.out.println(Integer.MAX_VALUE); // 2147483647System.out.println(Integer.MAX_VALUE + 1); // -2147483648 溢出 Java 81234567try &#123; Math.addExact(Integer.MAX_VALUE, 1);&#125;catch (ArithmeticException e) &#123; System.err.println(e.getMessage()); // =&gt; integer overflow&#125; 文件Files.list() 12345678try (Stream&lt;Path&gt; stream = Files.list(Paths.get(\"\"))) &#123; String joined = stream .map(String::valueOf) .filter(path -&gt; !path.startsWith(\".\")) .sorted() .collect(Collectors.joining(\"; \")); System.out.println(\"List: \" + joined);&#125; Files.find()12345678910Path start = Paths.get(\"\");int maxDepth = 5;try (Stream&lt;Path&gt; stream = Files.find(start, maxDepth, (path, attr) -&gt; String.valueOf(path).endsWith(\".js\"))) &#123; String joined = stream .sorted() .map(String::valueOf) .collect(Collectors.joining(\"; \")); System.out.println(\"Found: \" + joined);&#125; Files.walk()12345678910Path start = Paths.get(\"\");int maxDepth = 5;try (Stream&lt;Path&gt; stream = Files.walk(start, maxDepth)) &#123; String joined = stream .map(String::valueOf) .filter(path -&gt; path.endsWith(\".js\")) .sorted() .collect(Collectors.joining(\"; \")); System.out.println(\"walk(): \" + joined);&#125; Read and write files读整个文件，效率低123List&lt;String&gt; lines = Files.readAllLines(Paths.get(\"res/nashorn1.js\"));lines.add(\"print('foobar');\");Files.write(Paths.get(\"res/nashorn1-modified.js\"), lines); 一行一行读123456try (Stream&lt;String&gt; stream = Files.lines(Paths.get(\"res/nashorn1.js\"))) &#123; stream .filter(line -&gt; line.contains(\"print\")) .map(String::trim) .forEach(System.out::println);&#125; 使用缓冲1234Path path = Paths.get(\"res/nashorn1.js\");try (BufferedReader reader = Files.newBufferedReader(path)) &#123; System.out.println(reader.readLine());&#125; 1234Path path = Paths.get(\"res/output.js\");try (BufferedWriter writer = Files.newBufferedWriter(path)) &#123; writer.write(\"print('Hello World');\");&#125; 或者12345678Path path = Paths.get(\"res/nashorn1.js\");try (BufferedReader reader = Files.newBufferedReader(path)) &#123; long countPrints = reader .lines() .filter(line -&gt; line.contains(\"print\")) .count(); System.out.println(countPrints);&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://zhangliting.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://zhangliting.github.io/tags/Java/"}]},{"title":"JVM 内存模型","slug":"JVM-内存模型","date":"2017-04-24T12:56:35.000Z","updated":"2017-04-24T12:57:47.000Z","comments":true,"path":"2017/04/24/JVM-内存模型/","link":"","permalink":"http://zhangliting.github.io/2017/04/24/JVM-内存模型/","excerpt":"为了实现Java最重要的思想：一次编写，到处运行。Sun公司创建了Java虚拟机。虚拟机抽象了底层的操作系统，解析编译后的Java代码。JVM（Java Virtual Machine）是JRE（Java Runtime Environment）的核心，用于运行Java代码，现在也被其他语言使用（Scala，Groovy，JRuby，Closure.）。 这篇文章的重点在于JVM规范中描述的运行时数据区（Runtime Data Areas）。这些区域被设计为存储程序或由JVM本身使用的数据。首先我会概述，然后什么是字节码，最后解释不同的数据区域。","text":"为了实现Java最重要的思想：一次编写，到处运行。Sun公司创建了Java虚拟机。虚拟机抽象了底层的操作系统，解析编译后的Java代码。JVM（Java Virtual Machine）是JRE（Java Runtime Environment）的核心，用于运行Java代码，现在也被其他语言使用（Scala，Groovy，JRuby，Closure.）。 这篇文章的重点在于JVM规范中描述的运行时数据区（Runtime Data Areas）。这些区域被设计为存储程序或由JVM本身使用的数据。首先我会概述，然后什么是字节码，最后解释不同的数据区域。 概述JVM是对底层操作系统的抽象，不管底层的硬件和系统是否有差异，相同的代码在JVM上运行的结果保证一致。example: 整型的大小永远都是32位，范围 -2^31~2^31-1。 存储数据使用大端模式（高地址存放低位） Java代码先编译成字节码文件，JVM解析字节码文件。 为了避免磁盘I/O，JVM通过类加载器，报字节码文件加载到运行时数据区（RDA）。这些字节码会一直保存，直到JVM停止或类加载器销毁。 加载的字节码被执行引擎解析并执行。 执行引擎会保存正在执行的状态，以及与底层操作系统的协作。 注意：经常使用的代码会被编译成本地代码。这叫做即时编译（JIT），加快运行速度。 基于堆栈的架构JVM使用基于堆栈的架构。虽然，对于开发者它是不可见的，但是它对生成的字节码和JVM架构有巨大的影响。 JVM通过执行的Java字节码中描述的基本操作来执行开发人员的代码。操作数是指令操作的值。根据JVM规范，这些操作需要在操作栈中进行。 将操作数3，4入栈 调用加法指令 3，4出栈 计算3+4，将结果7入栈 注意： 其它的架构，如基于寄存器的架构，X86架构的处理器和Android虚拟机Dalvik使用。 字节码Java一个字节组成的操作码，有256中，其中，204个是Java8使用规范的。比如： ifeq(0x99) 表示equals iadd(0x66) 表示add i2l(0x85)integer 转 long arraylength(0xbe) 给出数组长度 pop（0x57）堆栈第一个元素出栈 简答的加法123456789101112public class Test &#123; public static void main(String[] args) &#123; int a =1; int b = 15; int result = add(a,b); &#125; public static int add(int a, int b)&#123; int result = a + b; return result; &#125;&#125; JDK提供javap，可以将字节码转成可以理解的语句。javap -verbose Test.class123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172Classfile /C:/TMP/Test.class Last modified 1 avr. 2015; size 367 bytes MD5 checksum adb9ff75f12fc6ce1cdde22a9c4c7426 Compiled from \"Test.java\"public class com.codinggeek.jvm.Test SourceFile: \"Test.java\" minor version: 0 major version: 51 flags: ACC_PUBLIC, ACC_SUPERConstant pool: #1 = Methodref #4.#15 // java/lang/Object.\"&lt;init&gt;\":()V #2 = Methodref #3.#16 // com/codinggeek/jvm/Test.add:(II)I #3 = Class #17 // com/codinggeek/jvm/Test #4 = Class #18 // java/lang/Object #5 = Utf8 &lt;init&gt; #6 = Utf8 ()V #7 = Utf8 Code #8 = Utf8 LineNumberTable #9 = Utf8 main #10 = Utf8 ([Ljava/lang/String;)V #11 = Utf8 add #12 = Utf8 (II)I #13 = Utf8 SourceFile #14 = Utf8 Test.java #15 = NameAndType #5:#6 // \"&lt;init&gt;\":()V #16 = NameAndType #11:#12 // add:(II)I #17 = Utf8 com/codinggeek/jvm/Test #18 = Utf8 java/lang/Object&#123; public com.codinggeek.jvm.Test(); flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object.\"&lt;init&gt;\":()V 4: return LineNumberTable: line 3: 0 public static void main(java.lang.String[]); flags: ACC_PUBLIC, ACC_STATIC Code: stack=2, locals=4, args_size=1 0: iconst_1 1: istore_1 2: bipush 15 4: istore_2 5: iload_1 6: iload_2 7: invokestatic #2 // Method add:(II)I 10: istore_3 11: return LineNumberTable: line 6: 0 line 7: 2 line 8: 5 line 9: 11 public static int add(int, int); flags: ACC_PUBLIC, ACC_STATIC Code: stack=2, locals=3, args_size=2 0: iload_0 1: iload_1 2: iadd 3: istore_2 4: iload_2 5: ireturn LineNumberTable: line 12: 0 line 13: 4&#125; 从上可知，不只是简单的转录Java类 包含了常量池的描述。常量池JVM数据区的一部分，用于存储类的元数据，如方法名称、参数…。当一个类被加载到JVM中，这些部分就会放在常量池中。 LineNumberTable 和 LocalVariableTable 指定了方法的位置和方法的变量。 加上了默认构造函数 指定了堆栈的操作信息。 运行时数据区运行时数据区是设计用来存储数据的内存区域。这些数据是由开发者的程序或JVM其内部工作使用。 堆 堆是所有JVM线程之间共享的内存区域。它是在虚拟机启动时创建的。所有的实例对象和数组被分配到堆中。如：12MyClass myVariable = new MyClass();MyClass[] myArrayClass = new MyClass[1024]; 堆必须要由垃圾回收器（GC）管理，当对象不使用时，由GC回收被分配的内存。GC的回收策略由取决于具体的JVM实现(Oracle Hotspot 就实现了很多算法） 堆可以动态扩大或收缩，也可以有固定的最大值和最小值。比如，在Oracle Hotspot里，用户可以指定参数：java -Xms=512m -Xmx=1024m 注意：堆不能超过最大值，否则会抛出OutOfMemoryError 方法区 方法区也是所有JVM线程共享的内存区域。也是在虚拟机启动时创建，并通过类加载器加载。方法区会一直保持，知道类加载器关闭。方法区保存： 类信息（字段、方法、父类名称、接口名称、版本…） 方法和构造函数的字节码表示 每个类都要加载的运行时常量池 JVM规范并没有强制要求方法区要在堆中实现。例如，Oracle HotSpot使用一种叫PermGen的区域来存储方法区。这个PermGen区邻居Java的堆，并限制了默认空间大小为64M（XX：MaxPermSize 可以修改）。从java 8开始，HotSpot把方法区存放在叫做Metaspace的独立的本地内存中。最大的可用空间等于系统可用的内存空间。 注意：如果方法区超过最大的范围，就会抛出OutOfMemoryError 运行时常量池 运行时常量池是方法区的子集。因为它是元数据的重要组成部分，Oracle规定将运行时常量池从方法区中分离出来。这个常量池会随着加载的类和接口而增加。这个常量池就像传统编程语言中的符号表。换句话说，当一个类、方法或字段被引用时，JVM会使用运行时常量池查找真实的内存地址。同时，常量池也保存字符串和基本类型的常量值。12String myString1 = “This is a string litteral”;static final int MY_CONSTANT=2; PC寄存器（每线程） 每个线程都有自己的PC（程序计数器）寄存器，与线程同时创建。任何时候，每一个线程都在执行当前的方法。寄存器指向当前正在执行的命令（在方法区）。 注意：如果方法被本地线程执行，那么寄存器的值是未知的。JVM的寄存器足够保存返回地址或指针。 Java虚拟机栈（每个线程） Java栈中保存了很多帧。 帧 帧是一种数据结构，它包含了很多数据，这些数据表示正在执行当前方法的线程状态。 操作数栈 本地变量数组 运行时常量池引用 栈 每个Java虚拟机线程有一个专用的Java虚拟机栈，与线程同时创建。栈保存了帧。每调一次方法，新的帧就会被放到栈中。当方法调用结束，帧也销毁了。不管是否正常结束。只有执行方法的帧，总是保持活动的。这个就是当前帧，它涉及当前方法和当前类。 example123456789public int add(int a, int b)&#123; return a + b;&#125; public void functionA()&#123;// some code without function call int result = add(2,3); //call to function B// some code without function call&#125; 注意：栈是动态的，但是有一个最大尺寸限制，如果递归调用过多，或引发StackOverflowErrorOracle HotSpot 可以修改-Xss 本地方法栈（每个线程） 只是为非Java语言写的本地方法（JNI）使用的栈，所以有操作系统控制。 总结希望这篇文章可以帮你更好的理解JVM。我觉得栈是重点，因为涉及到JVM的内部功能。如果想要深入理解： 你可以看看JVM规范 推荐Understanding JVM Internals","categories":[{"name":"JVM","slug":"JVM","permalink":"http://zhangliting.github.io/categories/JVM/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://zhangliting.github.io/tags/JVM/"}]},{"title":"Java 8 Date Time API","slug":"Java-8-Date-Time-API","date":"2017-04-24T12:54:16.000Z","updated":"2017-04-24T12:56:10.000Z","comments":true,"path":"2017/04/24/Java-8-Date-Time-API/","link":"","permalink":"http://zhangliting.github.io/2017/04/24/Java-8-Date-Time-API/","excerpt":"Java 8 Date Time API Clock为instant,date,time 提供时间，是包含时区的。123456// get the current timeClock clock = Clock.systemDefaultZone();long t0 = clock.millis();//Clock中获得Instant,载将Instant转DateInstant instant = clock.instant();Date legacyDate = Date.from(instant);","text":"Java 8 Date Time API Clock为instant,date,time 提供时间，是包含时区的。123456// get the current timeClock clock = Clock.systemDefaultZone();long t0 = clock.millis();//Clock中获得Instant,载将Instant转DateInstant instant = clock.instant();Date legacyDate = Date.from(instant); java.time.InstantInstant表示时间线上的一个点。 12345678910111213141516Instant now = Instant.now();//获得当前时间 不含时区 UTC时间//2014-09-20T14:32:33.646Z //从1970-01-01T00:00:00Z开始的毫秒数System.out.println(now.getEpochSecond());// prints 1411137153//加减Instant tomorrow = now.plus(1,ChronoUnit.DAYS);Instant tomorrow = now.plus(1,ChronoUnit.DAYS);//比较System.out.println(now.compareTo(tomorrow));// prints -1System.out.println(now.isAfter(yesterday));// prints true java.time.LocalDateLocalDate保存日期部分，不包含时区，是不可变得类。12345678910111213141516//当前日期LocalDate today = LocalDate.now();LocalDate tomorrow = today.plus(1, ChronoUnit.DAYS);LocalDate yesterday = tomorrow.minusDays(2);//自定义日期LocalDate independenceDay = LocalDate.of(2014, Month.JULY, 4);DayOfWeek dayOfWeek = independenceDay.getDayOfWeek();System.out.println(dayOfWeek); // FRIDAY//格式化日期DateTimeFormatter germanFormatter = DateTimeFormatter .ofLocalizedDate(FormatStyle.MEDIUM) .withLocale(Locale.GERMAN);LocalDate xmas = LocalDate.parse(\"24.12.2014\", germanFormatter);System.out.println(xmas); // 2014-12-24 java.time.LocalTimeLocalTime保存时间部分，不包含时区，是不可变得类。12345678910111213//当前时间LocalTime now = LocalTime.now();//自定义时间LocalTime late = LocalTime.of(23, 59, 59);System.out.println(late);//格式化时间DateTimeFormatter germanFormatter = DateTimeFormatter .ofLocalizedTime(FormatStyle.SHORT) .withLocale(Locale.GERMAN);LocalTime leetTime = LocalTime.parse(\"13:37\", germanFormatter);System.out.println(leetTime); java.time.LocalDateTimeLocalDateTime同时包括了时间和日期。不包含时区，是不可变得类。12345678//格式化DateTimeFormatter formatter = DateTimeFormatter .ofPattern(\"MMM dd, yyyy - HH:mm\");LocalDateTime parsed = LocalDateTime.parse(\"Nov 03, 2014 - 07:13\", formatter);String string = parsed.format(formatter);System.out.println(string); // Nov 03, 2014 - 07:13","categories":[{"name":"Java","slug":"Java","permalink":"http://zhangliting.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://zhangliting.github.io/tags/Java/"}]},{"title":"关系型数据库工作原理","slug":"关系型数据库工作原理","date":"2017-04-20T15:13:37.000Z","updated":"2017-04-20T14:15:31.000Z","comments":true,"path":"2017/04/20/关系型数据库工作原理/","link":"","permalink":"http://zhangliting.github.io/2017/04/20/关系型数据库工作原理/","excerpt":"关系型数据库工作原理 英文原文：http://coding-geek.com/how-databases-work/ ##概述 低层次和高层次的数据库组件 查询优化的过程 事务和缓冲池管理 O(1) vs O(n²)概念 时间复杂度是用来看看算法处理给定的数据需要多长时间。 时间复杂度的重点在于：随着数据的增加，需要处理的时间的变化。 O(1)的复杂度保持不变（常量） O(log(n))的复杂度较低 O(log(n)*n)和O(n）增加迅速 O(n²)的复杂度是最糟的 举例当数据量小的时候，O(1)和O(n²)区别并不明显，但是当数据量上亿时，就天差地别了。","text":"关系型数据库工作原理 英文原文：http://coding-geek.com/how-databases-work/ ##概述 低层次和高层次的数据库组件 查询优化的过程 事务和缓冲池管理 O(1) vs O(n²)概念 时间复杂度是用来看看算法处理给定的数据需要多长时间。 时间复杂度的重点在于：随着数据的增加，需要处理的时间的变化。 O(1)的复杂度保持不变（常量） O(log(n))的复杂度较低 O(log(n)*n)和O(n）增加迅速 O(n²)的复杂度是最糟的 举例当数据量小的时候，O(1)和O(n²)区别并不明显，但是当数据量上亿时，就天差地别了。 深入 在一个良好的哈希表中查找元素的复杂度O(1)。 在一个良好的平衡树种搜索的复杂度O(log(n)）。 在数组中查找的复杂度O(n)。 最好的排序方法复杂度O(n*log(n)) 坏的排序方法复杂度O(n²)。 复杂度： 一般情况 最好情况 最坏情况 归并排序思想 归并两个N/2的有序数组，只需要N次操作。将问题分割成可以结局的小问题。（分治思想） 比较两个数组中当前位置的元素。 将较小的元素放到新的数组里。 从较小的元素所在的数组，继续取一个元素与较大的元素比较。 重复1,2,3步骤，知道一个数组结束。 将另一个素组的剩余元素移到新的数组里。 伪代码12345678910111213array mergeSort(array a) if(length(a)==1) return a[0]; end if //recursive calls [left_array right_array] := split_into_2_equally_sized_arrays(a); array new_left_array := mergeSort(left_array); array new_right_array := mergeSort(right_array); //merging the 2 small ordered arrays into a big one array result := merge(new_left_array,new_right_array); return result; 分割阶段，将数组分成更小的数组。 排序阶段，将小的数组合并成更大的数组。 分割成log(n)步，每一步需要n次操作。所以时间复杂度O(n*log(n))。 为什么归并排序如此强大 你可以不创建新的数组，减少内存占用。（原位） 你可以只加载需要排序的部分，减少I/O操作和内存占用。（外部排序） 你可以在多线程服务器上运行。（分布式归并排序）（Hadoop） 数组，树和哈希表数组二维数组是最简单的数据结构，一张表可以看作一个二维数组。 每一行是一个主体。 列描述对象的特征。 每一列存储特定的类型（整数，字符串，日期等）的数据。 当你查找某一行数据时，需要遍历N行。 树和数据库索引二叉排序树是满足一下条件的二叉树： 左子树上所有节点的值均小于等于它的根节点的值。 右子树上所有节点的值均大于党羽它的根节点的值。 左右子树也都是二叉排序树。 二叉排序树查询的时间复杂度是O(log(n)),即是树的高度。对表中的任何字段加数据库索引，时间复杂度O(n) -&gt; O(log(n)) B+树索引当你需要查找某个范围内的所有值是，就需要遍历整棵树。时间复杂度O(n)。为了解决范围查询的问题，需要B+树定义： 只有最低的节点（叶子节点）存储信息 其他节点只是为了路由到正确的节点 B+树的节点数增加了一倍，查询的时间复杂度O(log(n)) + M。M是范围查询中的个数。如果你要查询40~100之间的值： 你需要查询40，或者最接近的值。 然后使用链接找到节点的后继节点，直到100。 当增加或删除数据的时候： 必须保持节点之间的顺序。（自有序） 尽量最小化树的高度。（自平衡） 插入和删除B+的时间复杂度是O(logn)，这就是为什么使用过多的索引并不是一个好主意。会减慢数据的插入和删除时间，同事增加事务管理的工作量。 Hash table 哈希表示一种根据Key快速找到值得数据结构。定义： 需要定义Key。 需要一个哈希函数，计算哈希值。 一个比较Key的方法。 example 找到78只需要2个操作，找到59，需要7个操作。真正的挑战是找到一个好的哈希函数，减少哈希冲突。好的哈希表复杂度O(1)。 哈希表 vs 数组 哈希表可以半加载到内存，另一半在磁盘。 数组必须连续空间。 哈希表的Key可以使用任何键。 总览数据库是一个提供数据访问和修改的数据集合。文件系统同样能做到。区别： 数据库使用事务，以确保数据的安全和一致。 能够快速处理大量的数据。 一个数据库由多个彼此交互的组件构成。核心组件 进程管理：很多数据库有自己的进程/线程池。为了达到纳秒级，很多数据库使用自己的线程，而不是操作系统的。 网络管理：网络I/O是一个大问题，尤其对于分布式数据库。 文件系统管理：磁盘I/O是数据库的瓶颈，良好的文件系统管理很重要。 内存管理：为了避免大量的磁盘I/O，需要一个高效的内存管理，尤其处理大量查询的时候。 安全管理：用于管理认证和用户授权。 客户端管理：管理客户端的连接。 。。。 数据库工具 备份管理器：用于保存和恢复的数据库。 恢复管理器：用于数据库崩溃后重新启动数据库。 监视管理：用于记录数据库的活动，并提供工具来监控数据库 管理员：用于存储元数据（如名称和表的结构），并提供工具来管理数据库，模式，表空间，… 查询管理器 查询分析器：检查查询是否有效 查询重写：预先优化查询 查询优化：优化查询 查询执行：编译和执行查询 数据管理 事务管理：处理事务 高速缓存管理器：把数据在内存中使用它们之前和磁盘上写他们之前把内存中的数据 数据访问管理：访问磁盘上的数据 客户端管理器客户端管理器是处理数据库和客户端交互的一部分，客户端可以是终端用户或终端应用。客户端管理器提供访问数据库的多种方式：JDBC，ODBC，OLE-DB… 连接数据库 管理器首先验证你的权限（用户名和密码），然后检查你时候有访问数据库的权限。这些权限由数据库管理员设置。 检查时候有可用的线程用于处理你的查询。 同时检查数据库是否过载。 客户端会等待一段时间，如果等待超时，关闭连接并返回错误信息。 连接成功，客户端会发送你的查询给查询管理器，SQL就会被执行。 当插到部分数据，就会返回给客户端。 关闭数据库连接，显示结果。 查询管理器这是数据库的强大所在。在这里，查询语句被转化成可以快速执行的代码。 查询语句首先被解析，看看它是否有效。 然后重写删除无用的操作，并添加一些优化。 再优化，以提高性能，并转化为执行和数据访问计划。 随后该计划被编译。 最后，执行。 查询分析器查询分析器会检查SQL的语法是否正确，然后使用数据库的元数据检查： 表是否存在 字段是否存在 当前操作是否可以在字段上执行 检查是否有读写的权限 这个过程常常将SQL被解析成语法树 SQL重写重写的目的： 预先优化查询 避免不必要的操作 帮助优化器找到最佳的解决方案 通过执行一系列的规则： 视图合并：如果查询语句使用了视图，转化成视图的SQL。 子查询展平：由于子查询很难优化，所以需要重写展平。 example123456SELECT PERSON.*FROM PERSONWHERE PERSON.person_key IN(SELECT MAILS.person_keyFROM MAILSWHERE MAILS.mail LIKE 'christophe%'); 转变成1234SELECT PERSON.*FROM PERSON, MAILSWHERE PERSON.person_key = MAILS.person_keyand MAILS.mail LIKE 'christophe%'; 移出不必要的操作：比如在Unique约束的字段上使用distinct 消除冗余的连接：比如你有两个连接条件，其中一个隐藏在试图中。 常量计算评估：比如where age &gt; 10 + 2 转成 where age &gt; 12 分区修剪：如果你使用分区表，重写器知道使用哪个分区。 自定义规则： Olap装换： 统计数据库会统计表信息 表中的行数/页 表中每一列的数据长度（最大，最小，均值） 标的索引信息 这些统计有助于优化查询，评估磁盘I/O，内存占用。Oracle：USER/ALL/DBA_TABLES and USER/ALL/DBA_TAB_COLUMNS 查询优化全表扫描：简单的读取整个表或者索引。从磁盘I/O的角度，全表扫描明显比全索引扫描更费时。 范围扫描：比如，where age &gt; 20 and age &lt; 40可以使用索引的范围扫描，前提是建立索引。时间复杂度log(n)+m。 唯一扫描：where age = 30 关联row id索引只保存了当前索引字段的值，并没有一条数据的完整记录，需要通过索引字段关联row id。 example1SELECT LASTNAME, FIRSTNAME from PERSON WHERE AGE = 28 利用索引只能找到age，需要返回表中查找其他字段。 内连接对于每个outer中的元素，在inner中查找相等的元素。时间复杂度O(N*M)伪代码： 12345678nested_loop_join(array outer, array inner) for each row a in outer for each row b in inner if (match_join_condition(a,b)) write_result_in_output(a,b) end if end for end for Hash join 获得inner的所有元素 使用inner在内存中建立hash表 遍历outer中的元素 计算outer的hash值，在hash表中查找 时间复杂度O(M+N) (The time complexity is (M/X) N + cost_to_create_hash_table(M) + cost_of_hash_functionN). X 是bucket个数，足够多时，可以忽略。 Merge join归并连接是唯一一个产生有序结果的连接。 前提是集合已经有序（不考虑重复元素的情况） 比较两个集合当前的元素（从第一开始）。 如果相等，将它们放到结果中，继续比较。 如果不相等，将较小的元素所在的集合向后找一个，继续比较。 重复前面的步骤，直到其中一个集合结束。 排序两个集合需要O(n*log(n)) + m*log(m))归并连接时间复杂度O(N+M) 哪一个是最好的？如果有一个最好的类型的连接，就不会有多种类型。这个问题是非常困难的，因为很多因素会喜欢打： 在可用内存量：没有足够的内存，你可以告别强大的散列连接（至少满内存哈希联接） 2个的数据集的大小。例如，如果你有一个大表，一个非常小的一个，嵌套循环连接会比散列快加入，因为哈希连接有一个昂贵的创建哈希。如果你有2个非常大的表格嵌套循环连接将是非常昂贵的CPU。 该存在 的 指标。随着2个B +树索引明智的选择似乎是合并连接如果结果需要进行排序：即使你未排序的数据集时，您可能需要使用昂贵的合并连接（与排序），因为在最后的结果将被排序，你就可以链与另一个合并连接的结果（或者也许是因为查询请求隐含/明确的排序结果与ORDER BY / GROUP BY / DISTINCT操作） 如果关系已经排序：在这种情况下，合并连接是最佳人选 该类型的连接，你正在做的：这是一个等值连接（即：tableA.col1 = tableB.col2）？它是一个内部联接，一个外连接，一个笛卡尔积或自连接？某些连接可以在某些情况下无法正常工作。 该数据的分布。如果连接条件的数据是倾斜（例如你在自己的姓氏加入的人，但很多人都有相同的），使用散列连接将是一场灾难，因为哈希函数将产生不良分布式桶。 如果你想联接由执行多个线程/进程 Example5张表关联123456SELECT * from PERSON, MOBILES, MAILS,ADRESSES, BANK_ACCOUNTSWHEREPERSON.PERSON_ID = MOBILES.PERSON_IDAND PERSON.PERSON_ID = MAILS.PERSON_IDAND PERSON.PERSON_ID = ADRESSES.PERSON_IDAND PERSON.PERSON_ID = BANK_ACCOUNTS.PERSON_ID 问题： 使用哪种关联？（hash join, merge join, nested join） join的先后顺序？ 这里有很多种组合的可能性，我们不可能去计算每一种可能的性能。更何况还有OUTER JOIN, CROSS JOIN,GROUP BY, ORDER BY….看看数据库是怎么做的？动态规划 贪心算法 查询计划缓存由于创建一个执行计划非常耗时，许多数据库都会缓存查询计划。数据库会设置一个threshold（阀值），当表的统计数据发生改变时，及时更新查询计划。 数据管理器这个阶段，查询管理器执行查询，需要获取表中的数据和索引。但是存在2个问题： 关系型数据库使用事务模型。 取数据是最耗时的操作。 缓存管理 就像之前提到的，数据库的瓶颈是磁盘I/O。所有数据库使用缓存管理器提高性能。查询执行器会先向缓存管理器请求数据。缓存管理器在内存中维持一个缓存池。从内存中直接拿数据显然很快。 这里涉及缓存预取 缓存命中策略 缓存清除策略LRU(最近最少使用) 事务管理ACID Atomicity：原子性。一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。 Consistency：持久性。事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。 Isolation：一致性。只有符合要求的数据保存到数据库。符合预期。 Durability：隔离性。两个事务的执行顺序不影响执行的结果。 事务隔离级别最高-&gt;最低 Serializable 可序列化：SQLite默认级别，两个事务完全不影响，100%隔离。 Repeatable read 可重复读：MySQL默认级别，当事务A修改了相同的记录，事务B不能看到A修改的记录，所以B可以重复读。但是A新增的记录（提交），B可以看到。如：select count(*) 会增加一条，这是幻读。 Read committed 读已提交：Oracle，PostgreSQL，SQL Server的默认级别，当事务A修改了相同的记录并提交，事务B可以看到A更新的记录。这是不可重复读 ead uncommitted 读未提交：事务A修改了相同的记录，未提交，事务B可以看到A修改的记录。当A滚记录，B又看到了之前的记录。这是脏读。 锁解决并发访问冲突的方式：锁（悲观锁）， 数据版本（乐观锁，类似git。修改的主干的拷贝，需要解决冲突） 悲观锁 如果某个事务需要一条数据，就给这条数据加上锁。 如果其他事务也想要这条数据，就必须等待之前的事务释放索。这也叫做排它锁 共享锁 如果一个只需要读这条数据A，就加共享锁，然后读取数据。 如果第二个事务也只读A，也加共享锁，然后读数据。 如果第三个事务需要修改A，就需要加排它锁，但是必须等待之前所有的共享锁释放。 同样，数据A已经加上了排它锁，一个事务读数据A，需要等待排它锁释放。 从图中可以看出，排它锁和共享锁不能共存。锁保存在hash表中，key是加锁的数据，value是哪个事务加的锁。 死锁事务A给data1加排它锁，事务B给data2加排它锁。事务A等待data2释放锁，事务B等待data1释放锁。 日志管理当数据库崩溃时，为了保持数据一致性： 拷贝：每一个事务在拷贝的数据上修改，提交时，更新主干数据。 事务日志：每次修改数据时，都会记录到日志中。 大多数数据库使用事务日志恢复数据库，因为拷贝很耗性能。 每一次修改数据提交，都会经历1-&gt;2-&gt;3-&gt;4-&gt;5为了性能，步骤5可以在commit之后执行，因为一旦崩溃还可以从日志中恢复。 总结数据库我们想得复杂和强大其他： 分布式数据库和全局事务 数据库快照 高效存储数据 内存管理 如果别人问题数据库是怎么工作的，你现在有能力告诉他： 推荐：“Architecture of Database System”","categories":[{"name":"数据库","slug":"数据库","permalink":"http://zhangliting.github.io/categories/数据库/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://zhangliting.github.io/tags/数据库/"}]},{"title":"一生受益的10句话","slug":"一生受益的10句话","date":"2017-04-20T15:02:42.000Z","updated":"2017-04-20T14:15:18.000Z","comments":true,"path":"2017/04/20/一生受益的10句话/","link":"","permalink":"http://zhangliting.github.io/2017/04/20/一生受益的10句话/","excerpt":"一生受益的10句话 原文：10 Life Lessons I have Learned in Last Few Years 在我的博客里，我一直都在谈论技术的东西。今天，我想要打破常规，分享我在生活和工作中学到的东西。我之所以分享我的想法，是因为我希望你们不要忽略生活中的小细节，这些小细节很重要。 相信我，我决定写这篇文章时，有很多事情浮现在我脑海。我想把所有的东西都写出来，但我需要保持文章的简洁。这样就会突出重点。希望这篇文章能使你“暂停并思考几分钟”。 “Life is a journey and it could be understood only backwards; but it must be lived forward.”","text":"一生受益的10句话 原文：10 Life Lessons I have Learned in Last Few Years 在我的博客里，我一直都在谈论技术的东西。今天，我想要打破常规，分享我在生活和工作中学到的东西。我之所以分享我的想法，是因为我希望你们不要忽略生活中的小细节，这些小细节很重要。 相信我，我决定写这篇文章时，有很多事情浮现在我脑海。我想把所有的东西都写出来，但我需要保持文章的简洁。这样就会突出重点。希望这篇文章能使你“暂停并思考几分钟”。 “Life is a journey and it could be understood only backwards; but it must be lived forward.” 个人生活的5句话1. 你的习惯塑造你的生活，小心选择习惯。Your habits shape your life. Choose them carefully 这对我来说是最好的学习。我们经常不会去想，我们生活中反复做的事情。大多数人不会意识到，我们每天做的事情居然成了我们的习惯。这些日常活动有些是好的，有些是坏的。不管你知道与否，终有一天会成为习惯。好的习惯对你的未来有积极的影响，坏的习惯从多个方面带给你伤害。小心选择你的习惯。保持好的习惯，如果你有坏的习惯，学着改掉。 判断习惯好坏最好的方法，是自己诚实的分析。拿出纸和笔，列出你每天做的事情。分析和总结它们对你的影响。选择什么对你有益，什么对你有害。做一个大胆的决定，并对这些习惯采取措施。 在开始你会发现，这是很难改变的习惯。在这里，我有一个建议给你。如果我没有记错的话，它是过希沃·哈拉说的“你可以赢”。我不记得确切的话，但我记得意图。 “If you want to control your everyday bad habits, just delay them as much as you can. Soon they will not be there.” 例如，如果你有吸烟的坏习惯，尽量拖延了1小时，然后2小时或更长时间，这取决于你制定的时间。然后增加了这种延迟。越早，你会发现，你能不吸烟很多天。实际上，你控制了。这样改掉坏喜欢很容易。 2. 诚实是最好的策略 Honesty is the best policy 这是通往有意义的生活的第二个重要步骤。说实话。欣赏诚实。重视诚信。它是你可以提供给你的雇主，你的朋友，每个人都关心你的最好的东西。现在的问题是，如何以及为什么需要诚实？ 有句老话说，我们应该永远说实话，因为这样我们就不必记得我们说什么。此外，当你知道别人对你不诚实的时候，是什么感受。这种感觉是一样的人。 做一些工作需要你告诉一个或两个谎言，特别是市场营销。真的吗？你认为真相会被一直隐藏吗？它不会出来？任何职业生活的信任和信赖来自诚信。这种信任实际上是转化为利润。更多的信任就是更多的回报。再想一想。如果你得到的回报是假币？你会怎么说？能说谎吗？ “Honesty is the best policy because no matter how good you are at telling lies, the truth will always come out.” 3. 家人和朋友是最重要的，用心保护他们Your family and friends are the best you got. Preserve them with all your heart 生活就是当你正在规划大事情的时候，发生在你身上的小事，。这些小东西大多是连接到你的家人和朋友。这包括你与他们度过的时刻，珍惜和他们在一起的时刻。你们中的大多数都会同意这一点，所以我不会使讨论长。我只想重温一句谚语： “I wish everybody gets what they want in their life, so that they can know that this is not the answer”. 4. 没有笑脸的一天是浪费生命A day you didn’t have a good laugh is a day wasted 一个好的笑声是最好的良药。它没有副作用和带来了许多积极的能量。正面的能量可以帮助你在面对艰难的情况。其实我骨子里是个逗比。我爱笑，时常笑。知道我的人，非常了解这点。我喜欢幽默，也很欣赏幽默。 5. 保持善心。帮助不幸的人Be kind. Do something for less fortunates 难道你不觉得你是上帝的幸运儿，给你一个非常舒适的生活。你的童年充满乐趣，你有一个公平的机会，在成年期，在一些跨国公司或一个好公司找到了一份工作。当我回头过去，我们没有今天这样锦衣足食。我们从没有饿肚子。我们是这个世界上少数的幸运儿。我们必须尊重这个事实，并一直记住这一切。 这也意味着，我们必须关系那些不太幸运的人。他们被迫饿着肚子睡觉。他们的每一步都为生存而挣扎的战斗。分享我们拥有的东西是我们的职责。在一天结束的时候，重要的是，你改变或触碰了多少生命。如果你没有，那么你浪费了你的生命。 职业生涯的5句话1. 艰苦的工作总是需要付出，永远不要放弃你的梦想Hard work always pays. Never ever give up your dreams 没有付出像辛勤工作那样。它总是会有回报的。所有你需要的是耐心和更艰苦的工作。我真诚地相信，在托马斯·爱迪生的名言： “Genius is 1% inspiration, 99% perspiration”. 这种艰苦的工作也应针对任何特定目标。这个目标是你的梦想。梦想一直很大。不要害怕障碍。努力工作一切都是值得的，你会实现的。没有简单的方法做艰苦的工作。你必须找到你的激情; 保持专注，直到作业完成的任务保持。你必须要保持强烈的动机。 我一直非常努力写这个博客。这不是顶级的博客，但它肯定是在正确的轨道上。在短短一年时间里，远高于许多老字号的博客排名。它带来了很多智者的关注，我的工作，也带来了一些钱也;-)。我一直都知道，功夫不负有心人，现在我也相信了。 2. 每天学习新的知识。每一天都值得Learn anything new everyday. Make everyday count 在很长一段时间里，这一直是我人生的座右铭，特别是当我开始写博客。我专门寻找我不知道的主题。我创建这样的主题列表。并尝试尽可能多的学习这些主题。每天至少一个主题。作为一个人，有时我跳过它，但我总是尽快试图清除积压。 请不要只用技术相关的项目在这里混淆。找到你的个人生活，以及你的爱好或你的创造力。任何新鲜的事情。例如，制作一个特别的菜，学习新魔术或读到一个很酷的应用程序。你可以把任何东西列在列表中。 到目前为止，对我的回报已经超过了我的预期。我已经在工作中得到了很多的信心。在过去的一年中，我从来没有的技术面试中失败过。这对许多人来说是非常令人不可思议的事情。好吧，我只是按照这个简单的规则来做。你可以试试。 3. 团结使我们更出色We are better when we are connected. Make connections 这实际上是在“美国银行”的妙语，现在的雇主。但是，在我加入这家银行之前就知道了这个真理。你一定听说过，人是社会的动物。如果你想在职业生涯成长，互相接触并保持联系。当您在复杂的情况下，这些有助于你解决问题。你可以得到更多的发展机会，因为你是唯一的，大家都知道。 在这里，我不建议任何形式的奉承别人。有时拍马屁虽然成功，但不是长远之计。所有我想说的是社交。了解的同事的家庭成员。谈论它们。进行个人离线交流。跟同事做朋友。千万不要总是打扰他们。邀请他们去餐厅喝茶。这同样适用于你的客户。开始会议前，提前10分钟登录，如果他们有空，跟他们谈他们的家庭，他们的文化，他们的节日或任何你能想到的。所有这些东西将使你们连接在一起。 4. 不要犹豫问问题，积极参加会议Never hesitate in asking questions. Make active participation in meetings 我在我的职业生涯的开始是一个懒惰的人。我当时因为种种原因也很害羞。每当团队会议发生在那个时候，我与所有的人都一样。有时候，我有问题，但我犹豫了。你知道吗？，他们从来没有得到回答。你从来不问，什么问题都将永远不会得到回答。 我依然很容易记起，我失去的这些机会，因为这些机会都很重要。我失去了他们。但是，我再也不会犯同样的错误。其实，在这方面，我已经进步了很多。 5. 沟通技巧是你最好的武器，每天都要练习Communication skills are your best weapon. Sharp them everyday 你们中的大多数都认为英语是最占主导地位的语言。我很尊重我的母语-“印地文”，喜欢在我的个人生活交谈。但我可以很容易地说，英语是在我们这个行业更重要。英语是全球通用的语言。你的工作职责要求你与人不同的文化和语言交流。英语填补了这个空白。所以，如果你想与他们沟通，掌握语言。一旦你掌握的语言，更多的机会来了。 请注意，当我说英语是很重要的，这意味着在英语中的一个很好的命令。你应该进行有效的沟通。你应该有过的词汇也是一个不错的命令。这是上述四句话的前提。它可以使你自信，让你可以成功做到上面四点。","categories":[{"name":"经验","slug":"经验","permalink":"http://zhangliting.github.io/categories/经验/"}],"tags":[{"name":"经验","slug":"经验","permalink":"http://zhangliting.github.io/tags/经验/"}]},{"title":"Java 设计原则","slug":"Java-设计原则","date":"2017-04-19T14:26:09.000Z","updated":"2017-04-19T13:27:55.000Z","comments":true,"path":"2017/04/19/Java-设计原则/","link":"","permalink":"http://zhangliting.github.io/2017/04/19/Java-设计原则/","excerpt":"Java 设计原则5个Java类设计原则 单一职责原则 一个类有且只有一个职责。 一个entity对应一张表。 service类不应该含有工具方法。 便于维护。","text":"Java 设计原则5个Java类设计原则 单一职责原则 一个类有且只有一个职责。 一个entity对应一张表。 service类不应该含有工具方法。 便于维护。 开闭原则 软件组件应该对扩展开放，对修改关闭。 像Spring框架，类的核心功能不能被修改，但你可以覆写某些方法，以满足你的需求。 里氏的替换原则 派生的类型必须完全可以替代它们的父类。 子类可以实现父类的抽象方法，但不能改变父类原有的方法。 子类可以增加自己的方法 接口隔离原则 客户不应该被强迫实现他们不必要的方法。 如果借口如果借口eportable有两个方法generateExcel()，eneratedPdf()。但是我只需要生成PDF，这就需要把两个方法分别放在PdfReportable，ExcelReportable。 依赖倒置原则 依赖抽象，而不是具体实现。 Spring framework的BeanFactory就是经典的例子。 所有的模块都是分离的，需要的模块通过依赖注入。 降低模块的耦合，便于维护和扩展。","categories":[{"name":"Java","slug":"Java","permalink":"http://zhangliting.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://zhangliting.github.io/tags/Java/"}]},{"title":"Java 8 避免空检查","slug":"Java-8-避免空检查","date":"2017-04-19T14:16:29.000Z","updated":"2017-04-19T13:25:34.000Z","comments":true,"path":"2017/04/19/Java-8-避免空检查/","link":"","permalink":"http://zhangliting.github.io/2017/04/19/Java-8-避免空检查/","excerpt":"Java 8 避免空检查 概述null的发明者Tony Hoare在2009年致歉，表述了这个billion-dollar mistake。 I call it my billion-dollar mistake. It was the invention of the null reference in 1965. At that time, I was designing the first comprehensive type system for references in an object oriented language (ALGOL W). My goal was to ensure that all use of references should be absolutely safe, with checking performed automatically by the compiler. But I couldn’t resist the temptation to put in a null reference, simply because it was so easy to implement. This has led to innumerable errors, vulnerabilities, and system crashes, which have probably caused a billion dollars of pain and damage in the last forty years.","text":"Java 8 避免空检查 概述null的发明者Tony Hoare在2009年致歉，表述了这个billion-dollar mistake。 I call it my billion-dollar mistake. It was the invention of the null reference in 1965. At that time, I was designing the first comprehensive type system for references in an object oriented language (ALGOL W). My goal was to ensure that all use of references should be absolutely safe, with checking performed automatically by the compiler. But I couldn’t resist the temptation to put in a null reference, simply because it was so easy to implement. This has led to innumerable errors, vulnerabilities, and system crashes, which have probably caused a billion dollars of pain and damage in the last forty years. 举例 定义三层嵌套的类 123456789101112131415161718class Outer &#123; Nested nested; Nested getNested() &#123; return nested; &#125;&#125;class Nested &#123; Inner inner; Inner getInner() &#123; return inner; &#125;&#125;class Inner &#123; String foo; String getFoo() &#123; return foo; &#125;&#125; 原始避免NullPointerException的方法很繁琐 1234Outer outer = new Outer();if (outer != null &amp;&amp; outer.nested != null &amp;&amp; outer.nested.inner != null) &#123; System.out.println(outer.nested.inner.foo);&#125; Java 8 使用Optinal的map，它接受一个Function，封装为Optional对象。 12345Optional.of(new Outer()) .map(Outer::getNested) .map(Nested::getInner) .map(Inner::getFoo) .ifPresent(System.out::println); 另一种通过Supplier方法 (个人不推荐主动捕获NullPointerException） 123456789public static &lt;T&gt; Optional&lt;T&gt; resolve(Supplier&lt;T&gt; resolver) &#123; try &#123; T result = resolver.get(); return Optional.ofNullable(result); &#125; catch (NullPointerException e) &#123; return Optional.empty(); &#125;&#125; 123Outer obj = new Outer();resolve(() -&gt; obj.getNested().getInner().getFoo()); .ifPresent(System.out::println); 调用obj.getNested().getInner().getFoo()可能抛出NullPointerException。这里手动捕获了异常，并返回Optional.empty()","categories":[{"name":"Java","slug":"Java","permalink":"http://zhangliting.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://zhangliting.github.io/tags/Java/"}]},{"title":"Java 面试题(2)","slug":"Java-面试题( 2 )","date":"2017-04-18T14:34:51.000Z","updated":"2017-04-19T13:24:47.816Z","comments":true,"path":"2017/04/18/Java-面试题( 2 )/","link":"","permalink":"http://zhangliting.github.io/2017/04/18/Java-面试题( 2 )/","excerpt":"Java 面试题（2） 避免使用finalize()方法finalize()方法会被GC线程调用，但不保证执行。 finalize（）方法不会像constructor()一样调用super finalize()。 finalize()方法抛出的异常会被GC忽略。 finalize()降低性能。 notify()和wait()为什么定义在Object class notify(), wait(), notifyAll()，用于多线程共享资源。 定义在Object class，所有的对象都可以控制调用它的线程必须等待monitor。 Java使用Hoare’s monitors idea。 Java不能指定某个线程运行，总是当前的线程远行代码。但是可以指定监视器（调用wait()等待获取监视器,notify()释放监视器））。 这是一个好的设计，如果一个线程可以随时改变其他线程等待监视器，就会导致侵入。这是不提倡的，就像stop()。","text":"Java 面试题（2） 避免使用finalize()方法finalize()方法会被GC线程调用，但不保证执行。 finalize（）方法不会像constructor()一样调用super finalize()。 finalize()方法抛出的异常会被GC忽略。 finalize()降低性能。 notify()和wait()为什么定义在Object class notify(), wait(), notifyAll()，用于多线程共享资源。 定义在Object class，所有的对象都可以控制调用它的线程必须等待monitor。 Java使用Hoare’s monitors idea。 Java不能指定某个线程运行，总是当前的线程远行代码。但是可以指定监视器（调用wait()等待获取监视器,notify()释放监视器））。 这是一个好的设计，如果一个线程可以随时改变其他线程等待监视器，就会导致侵入。这是不提倡的，就像stop()。 DeadLock Example死锁:两个线程同时持有一些不同的资源，同时请求对方的资源。 一个死锁的例子：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package thread; public class ResolveDeadLockTest &#123; public static void main(String[] args) &#123; ResolveDeadLockTest test = new ResolveDeadLockTest(); //创建2个资源 final A a = test.new A(); final B b = test.new B(); // Thread-1 Runnable block1 = new Runnable() &#123; public void run() &#123; synchronized (a) &#123; try &#123; // Adding delay so that both threads can start trying to // lock resources Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; // Thread-1 have A but need B also synchronized (b) &#123; System.out.println(\"In block 1\"); &#125; &#125; &#125; &#125;; // Thread-2 Runnable block2 = new Runnable() &#123; public void run() &#123; synchronized (b) &#123; // Thread-2 have B but need A also synchronized (a) &#123; System.out.println(\"In block 2\"); &#125; &#125; &#125; &#125;; new Thread(block1).start(); new Thread(block2).start(); &#125; // Resource A private class A &#123; private int i = 10; public int getI() &#123; return i; &#125; public void setI(int i) &#123; this.i = i; &#125; &#125; // Resource B private class B &#123; private int i = 20; public int getI() &#123; return i; &#125; public void setI(int i) &#123; this.i = i; &#125; &#125;&#125; 解决方法：多个线程调用资源的顺序一致，a-&gt;b。 Transient Transient关键字表示一个字段不应该被序列化和持久化。 Volatile 每一个线程都有自己的本地内存空间，线程的读写操作都在本地内存空间上进行。当所有操作完成，线程把本地内存中修改的变量写回到主内存空间。 volatile告诉JVM，保证本地内存空间的变量和主内存一致。每一次线程读取某个volatiel修饰的变量时，都会去主内存获取最新的值。 volatile也可以防止指令重排。 Iterator and ListIterator 区别 Iterator：Set，List，Map。 ListIterator：List。 ListIterator can iterate backwards. obtain the index at any point. add a new value at any point. set a new value at that point. Copy Java 默认是shallow copy, 基本类型会创建相同的对象。引用类只会创建同一个引用。 Java实现copy 实现Cloneable接口。 覆写clone()方法。 Example 12345678910111213141516171819public class Employee implements Cloneable&#123; private int empoyeeId; private String employeeName; private Department department;// shallow copy public Employee(int id, String name, Department dept) &#123; this.empoyeeId = id; this.employeeName = name; this.department = dept; &#125; @Override protected Object clone() throws CloneNotSupportedException &#123; return super.clone(); &#125; //Accessor/mutators methods will go there&#125; 手动修改Department to deep copy 1234567/Modified clone() method in Employee class@Overrideprotected Object clone() throws CloneNotSupportedException &#123; Employee cloned = (Employee)super.clone(); cloned.setDepartment((Department)cloned.getDepartment().clone()); return cloned;&#125; 同时Departments要实现clone()。12345//Defined clone method in Department class.@Overrideprotected Object clone() throws CloneNotSupportedException &#123; return super.clone();&#125; 序列化实现深拷贝 12345678910111213141516171819public SerializableClass deepCopy() throws Exception &#123; //Serialization of object ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream out = new ObjectOutputStream(bos); out.writeObject(this); //De-serialization of object ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray()); ObjectInputStream in = new ObjectInputStream(bis); SerializableClass copied = (SerializableClass) in.readObject(); //Verify that object is not corrupt //validateNameParts(fName); //validateNameParts(lName); return copied; &#125; Using Apache commons内部使用序列化，deep copy 1SomeObject cloned = org.apache.commons.lang.SerializationUtils.clone(someObject); Best Practices 123456if(obj1 instanceof Cloneable)&#123; obj2 = obj1.clone();&#125; //Dont do this. Cloneabe dont have any methodsobj2 = (Cloneable)obj1.clone() &amp;&amp; and &amp; 区别 &amp; 是位运算符，&amp;&amp;是逻辑运算符。 &amp;&amp; 左边是true，就不会执行右边的。 访问修饰符 Modifiers Same Class Same Package Subclass Other packages public Y Y Y Y protected Y Y Y N default Y Y N N private Y N N N Java native 方法 native关键字修饰的方法，使用JNI调用非Java的方法。 调用非Java写的方法。 需要调用系统资源相关的方法","categories":[{"name":"Java","slug":"Java","permalink":"http://zhangliting.github.io/categories/Java/"}],"tags":[{"name":"Java 面试","slug":"Java-面试","permalink":"http://zhangliting.github.io/tags/Java-面试/"}]},{"title":"Java 8 简明教程","slug":"Java-8-简明教程","date":"2017-04-18T14:34:18.000Z","updated":"2017-04-19T13:22:19.000Z","comments":true,"path":"2017/04/18/Java-8-简明教程/","link":"","permalink":"http://zhangliting.github.io/2017/04/18/Java-8-简明教程/","excerpt":"Java 8 简明教程 “Java is still not dead–and people are starting to fingure that out”. 接口默认方法 java 8 可以在接口中使用default定义默认方法。可以多个 example:1234567interface Formula &#123; double calculate(int a); default double sqrt(int a) &#123; return Math.sqrt(a); &#125;&#125; Lambda 表达式 数组排序 老的方式 12345678List&lt;String&gt; names = Arrays.asList(\"peter\", \"anna\", \"mike\", \"xenia\");//匿名内部类Collections.sort(names, new Comparator&lt;String&gt;() &#123; @Override public int compare(String a, String b) &#123; return b.compareTo(a); &#125;&#125;);","text":"Java 8 简明教程 “Java is still not dead–and people are starting to fingure that out”. 接口默认方法 java 8 可以在接口中使用default定义默认方法。可以多个 example:1234567interface Formula &#123; double calculate(int a); default double sqrt(int a) &#123; return Math.sqrt(a); &#125;&#125; Lambda 表达式 数组排序 老的方式 12345678List&lt;String&gt; names = Arrays.asList(\"peter\", \"anna\", \"mike\", \"xenia\");//匿名内部类Collections.sort(names, new Comparator&lt;String&gt;() &#123; @Override public int compare(String a, String b) &#123; return b.compareTo(a); &#125;&#125;); java 8 Lambda 123Collections.sort(names, (String a, String b) -&gt; &#123; return b.compareTo(a);&#125;); 进一步简化 1Collections.sort(names, (String a, String b) -&gt; b.compareTo(a)); 再简化，省略参数类型。编译器会自动识别参数类型 1names.sort((a, b) -&gt; b.compareTo(a)); 函数接口 一个Lamda表达式对应于一个函数接口中的抽象方法。 一个函数接口有且只有一个抽象方法。 @FunctionalInterface（省略不报错）注解告诉编译器这是函数接口，以保证只有一个抽象方法。 Example: 1234@FunctionalInterfaceinterface Converter&lt;F, T&gt; &#123; T convert(F from);&#125; 123Converter&lt;String, Integer&gt; converter = (from) -&gt; Integer.valueOf(from);Integer converted = converter.convert(\"123\");System.out.println(converted); // 123 方法和构造函数引用 java 8 允许使用::关键字引用对象的方法和构造函数 引用静态方法 123Converter&lt;String, Integer&gt; converter = Integer::valueOf;Integer converted = converter.convert(\"123\");System.out.println(converted); // 123 引用非静态方法 12345class Something &#123; String startsWith(String s) &#123; return String.valueOf(s.charAt(0)); &#125;&#125; 1234Something something = new Something();Converter&lt;String, String&gt; converter = something::startsWith;String converted = converter.convert(\"Java\");System.out.println(converted); // \"J\" 引用构造函数 1234567891011class Person &#123; String firstName; String lastName; Person() &#123;&#125; Person(String firstName, String lastName) &#123; this.firstName = firstName; this.lastName = lastName; &#125;&#125; Java编译器会根据函数接口方法的参数，自动选择符合声明的构造方法。123interface PersonFactory&lt;P extends Person&gt; &#123; P create(String firstName, String lastName);&#125; 12PersonFactory&lt;Person&gt; personFactory = Person::new;Person person = personFactory.create(\"Peter\", \"Parker\"); Lambda 表达式的范围与匿名内部类类似， 你可以在Lambda表达式中访问final局部变量、实例变量以及静态变量。 访问局部变量12345final int num = 1;Converter&lt;Integer, String&gt; stringConverter = (from) -&gt; String.valueOf(from + num);stringConverter.convert(2); // 3 与匿名内部类不同的是，被Lambda表达式使用的变量默认为final，可以省略final。 12345int num = 1;Converter&lt;Integer, String&gt; stringConverter = (from) -&gt; String.valueOf(from + num);stringConverter.convert(2); // 3 num默认final，以下代码num = 3会编译错误。 1234int num = 1;Converter&lt;Integer, String&gt; stringConverter = (from) -&gt; String.valueOf(from + num);num = 3; 访问实例变量和静态变量12345678910111213141516class Lambda4 &#123; static int outerStaticNum; int outerNum; void testScopes() &#123; Converter&lt;Integer, String&gt; stringConverter1 = (from) -&gt; &#123; outerNum = 23; return String.valueOf(from); &#125;; Converter&lt;Integer, String&gt; stringConverter2 = (from) -&gt; &#123; outerStaticNum = 72; return String.valueOf(from); &#125;; &#125;&#125; 访问函数接口默认方法 默认方法不能通过Lambda表达式调用。1Formula formula = (a) -&gt; sqrt(a * 100);//错误 Java 8 内置函数接口 旧接口升级成函数接口 Comparator Runnable 类似 Google Guava library. Predicate (判断) Predicate 接受一个参数，返回boolean类型。 定义 123456789101112@FunctionalInterfacepublic interface Predicate&lt;T&gt; &#123; /** * Evaluates this predicate on the given argument. * * @param t the input argument * @return &#123;@code true&#125; if the input argument matches the predicate, * otherwise &#123;@code false&#125; */ boolean test(T t); ... example 12345678910Predicate&lt;String&gt; predicate = (s) -&gt; s.length() &gt; 0;predicate.test(\"foo\"); // truepredicate.negate().test(\"foo\"); // falsePredicate&lt;Boolean&gt; nonNull = Objects::nonNull;Predicate&lt;Boolean&gt; isNull = Objects::isNull;Predicate&lt;String&gt; isEmpty = String::isEmpty;Predicate&lt;String&gt; isNotEmpty = isEmpty.negate(); Functions (函数) Functions 接受一个参数，返回一个处理后的参数。 定义 1234567891011@FunctionalInterfacepublic interface Function&lt;T, R&gt; &#123; /** * Applies this function to the given argument. * * @param t the function argument * @return the function result */ R apply(T t); ... example 1234Function&lt;String, Integer&gt; toInteger = Integer::valueOf;Function&lt;String, String&gt; backToString = toInteger.andThen(String::valueOf);backToString.apply(\"123\"); // \"123\" Suppliers (生产者） Suppliers 不接受参数，返回一个对象。 定义 12345678910@FunctionalInterfacepublic interface Supplier&lt;T&gt; &#123; /** * Gets a result. * * @return a result */ T get();&#125; example 12Supplier&lt;Person&gt; personSupplier = Person::new;personSupplier.get(); // new Person Consumers (消费者) Consumers 接受一个参数，不返回。 定义 12345678910@FunctionalInterfacepublic interface Consumer&lt;T&gt; &#123; /** * Performs this operation on the given argument. * * @param t the input argument */ void accept(T t); ... example 12Consumer&lt;Person&gt; greeter = (p) -&gt; System.out.println(\"Hello, \" + p.firstName);greeter.accept(new Person(\"Luke\", \"Skywalker\")); Comparator (比较器) java 8 增加了默认方法 定义 12345@FunctionalInterfacepublic interface Comparator&lt;T&gt; &#123; int compare(T o1, T o2); ... example 1234567Comparator&lt;Person&gt; comparator = (p1, p2) -&gt; p1.firstName.compareTo(p2.firstName);Person p1 = new Person(\"John\", \"Doe\");Person p2 = new Person(\"Alice\", \"Wonderland\");comparator.compare(p1, p2); // &gt; 0comparator.reversed().compare(p1, p2); // &lt; 0 Optional Optionals 可以避免 NullPointerException. Optional是一个容器，空或者非空。example 1234567Optional&lt;String&gt; optional = Optional.of(\"bam\");optional.isPresent(); // trueoptional.get(); // \"bam\"optional.orElse(\"fallback\"); // \"bam\"optional.ifPresent((s) -&gt; System.out.println(s.charAt(0))); // \"b\" Streams ( 流） java.util.Stream 可以执行一系列的流操作。 java.util.Collection like lists or sets (maps are not supported) 可以转化成Stream. Stream 可以并行执行。 123456789List&lt;String&gt; stringCollection = new ArrayList&lt;&gt;();stringCollection.add(\"ddd2\");stringCollection.add(\"aaa2\");stringCollection.add(\"bbb1\");stringCollection.add(\"aaa1\");stringCollection.add(\"bbb3\");stringCollection.add(\"ccc\");stringCollection.add(\"bbb2\");stringCollection.add(\"ddd1\"); Filter Filter 接受一个Predicate，根据Predicate过滤集合，这是一个中间操作。 123456stringCollection .stream() .filter((s) -&gt; s.startsWith(\"a\")) .forEach(System.out::println);// \"aaa2\", \"aaa1\" Sorted Sorted 是中间操作，默认按自然顺序排序，可以接受一个Comparator。 Sorted 不会影响原来集合的排序。 1234567stringCollection .stream() .sorted() .filter((s) -&gt; s.startsWith(\"a\")) .forEach(System.out::println);// \"aaa1\", \"aaa2\" 12System.out.println(stringCollection);// ddd2, aaa2, bbb1, aaa1, bbb3, ccc, bbb2, ddd1 Map Map 是中间操作，接受一个Function，一对一的映射。 1234567stringCollection .stream() .map(String::toUpperCase) .sorted((a, b) -&gt; b.compareTo(a)) .forEach(System.out::println);// \"DDD2\", \"DDD1\", \"CCC\", \"BBB3\", \"BBB2\", \"AAA2\", \"AAA1\" Match Match是一个终止操作，接受Predicate，返回boolean。 1234567891011121314151617181920boolean anyStartsWithA = stringCollection .stream() .anyMatch((s) -&gt; s.startsWith(\"a\"));System.out.println(anyStartsWithA); // trueboolean allStartsWithA = stringCollection .stream() .allMatch((s) -&gt; s.startsWith(\"a\"));System.out.println(allStartsWithA); // falseboolean noneStartsWithZ = stringCollection .stream() .noneMatch((s) -&gt; s.startsWith(\"z\"));System.out.println(noneStartsWithZ); // true Count Count 是一个终止操作，计算返回的元素个数，返回long。 1234567long startsWithB = stringCollection .stream() .filter((s) -&gt; s.startsWith(\"b\")) .count();System.out.println(startsWithB); // 3 Reduce Reduce是终止操作，接受BiFunction。返回Optional。 12345678Optional&lt;String&gt; reduced = stringCollection .stream() .sorted() .reduce((s1, s2) -&gt; s1 + \"#\" + s2);reduced.ifPresent(System.out::println);// \"aaa1#aaa2#bbb1#bbb2#bbb3#ccc#ddd1#ddd2\" Collect 将流转成集合的终止操作，Collectors.toList(), Collectors.toSet(). 1234567List&lt;Person&gt; filtered = persons .stream() .filter(p -&gt; p.name.startsWith(\"P\")) .collect(Collectors.toList());System.out.println(filtered); // [Peter, Pamela] 分组 Collectors.groupingBy() 123Map&lt;Integer, List&lt;Person&gt;&gt; personsByAge = persons .stream() .collect(Collectors.groupingBy(p -&gt; p.age)); Collections.summaizeingInt() 1234567IntSummaryStatistics ageSummary = persons .stream() .collect(Collectors.summarizingInt(p -&gt; p.age));System.out.println(ageSummary);// IntSummaryStatistics&#123;count=4, sum=76, min=12, average=19.000000, max=23&#125; Collections.joining(); 12345String phrase = persons .stream() .filter(p -&gt; p.age &gt;= 18) .map(p -&gt; p.name) .collect(Collectors.joining(\" and \", \"In Germany \", \" are of legal age.\")); Collection.toMap() 123456789Map&lt;Integer, String&gt; map = persons .stream() .collect(Collectors.toMap( p -&gt; p.age, p -&gt; p.name, (name1, name2) -&gt; name1 + \";\" + name2));System.out.println(map);// &#123;18=Max, 23=Peter;Pamela, 12=David&#125; 自定义Collection 123456789101112Collector&lt;Person, StringJoiner, String&gt; personNameCollector = Collector.of( () -&gt; new StringJoiner(\" | \"), // supplier (j, p) -&gt; j.add(p.name.toUpperCase()), // accumulator (j1, j2) -&gt; j1.merge(j2), // combiner StringJoiner::toString); // finisherString names = persons .stream() .collect(personNameCollector);System.out.println(names); // MAX | PETER | PAMELA | DAVID FlatMap12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class Streams7 &#123; static class Foo &#123; String name; List&lt;Bar&gt; bars = new ArrayList&lt;&gt;(); Foo(String name) &#123; this.name = name; &#125; &#125; static class Bar &#123; String name; Bar(String name) &#123; this.name = name; &#125; &#125; public static void main(String[] args) &#123;// test1(); test2(); &#125; static void test2() &#123; IntStream.range(1, 4) .mapToObj(num -&gt; new Foo(\"Foo\" + num)) .peek(f -&gt; IntStream.range(1, 4) .mapToObj(num -&gt; new Bar(\"Bar\" + num + \" &lt;- \" + f.name)) .forEach(f.bars::add)) .flatMap(f -&gt; f.bars.stream()) .forEach(b -&gt; System.out.println(b.name)); &#125; static void test1() &#123; List&lt;Foo&gt; foos = new ArrayList&lt;&gt;(); IntStream .range(1, 4) .forEach(num -&gt; foos.add(new Foo(\"Foo\" + num))); foos.forEach(f -&gt; IntStream .range(1, 4) .forEach(num -&gt; f.bars.add(new Bar(\"Bar\" + num + \" &lt;- \" + f.name)))); foos.stream() .flatMap(f -&gt; f.bars.stream()) .forEach(b -&gt; System.out.println(b.name)); &#125;&#125; Optinal的flatMap使用12345Optional.of(new Outer()) .flatMap(o -&gt; Optional.ofNullable(o.nested)) .flatMap(n -&gt; Optional.ofNullable(n.inner)) .flatMap(i -&gt; Optional.ofNullable(i.foo)) .ifPresent(System.out::println); Stream 进阶其他的Stream123456789101112131415161718192021222324Stream.of(\"a1\", \"a2\", \"a3\") .findFirst() .ifPresent(System.out::println); // a1 IntStream.range(1, 4) .forEach(System.out::println);// 1// 2// 3// int array to streamArrays.stream(new int[] &#123;1, 2, 3&#125;) .map(n -&gt; 2 * n + 1) .average() .ifPresent(System.out::println); // 5.0 Stream.of(1.0, 2.0, 3.0) .mapToInt(Double::intValue) .mapToObj(i -&gt; \"a\" + i) .forEach(System.out::println);// a1// a2// a3 Stream处理顺序 以下代码不会打印，因为没有终止操作。只有终止操作存在的时候，中间操作才虎执行。 12345Stream.of(\"d2\", \"a2\", \"b1\", \"b3\", \"c\") .filter(s -&gt; &#123; System.out.println(\"filter: \" + s); return true; &#125;); 只要anymatch满足，就不会继续执行别的元素。由此可见，第一个元素走完全部，才会执行后面的元素。 1234567891011121314Stream.of(\"d2\", \"a2\", \"b1\", \"b3\", \"c\") .map(s -&gt; &#123; System.out.println(\"map: \" + s); return s.toUpperCase(); &#125;) .anyMatch(s -&gt; &#123; System.out.println(\"anyMatch: \" + s); return s.startsWith(\"A\"); &#125;);// map: d2// anyMatch: D2// map: a2// anyMatch: A2 Stream的处理顺序很重要，尽量先筛选再处理。 Stream 重复使用 一旦Stream终止，流就会关闭，不能再使用。123456Stream&lt;String&gt; stream = Stream.of(\"d2\", \"a2\", \"b1\", \"b3\", \"c\") .filter(s -&gt; s.startsWith(\"a\"));stream.anyMatch(s -&gt; true); // okstream.noneMatch(s -&gt; true); // exception 12345java.lang.IllegalStateException: stream has already been operated upon or closed at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:229) at java.util.stream.ReferencePipeline.noneMatch(ReferencePipeline.java:459) at com.winterbe.java8.Streams5.test7(Streams5.java:38) at com.winterbe.java8.Streams5.main(Streams5.java:28) 解决方法：用中间过程的流创建一个Supplier，返回Stream。 123456Supplier&lt;Stream&lt;String&gt;&gt; streamSupplier = () -&gt; Stream.of(\"d2\", \"a2\", \"b1\", \"b3\", \"c\") .filter(s -&gt; s.startsWith(\"a\"));streamSupplier.get().anyMatch(s -&gt; true); // okstreamSupplier.get().noneMatch(s -&gt; true); // ok Parallel Streams （并行流）First we create a large list of unique elements: 123456int max = 1000000;List&lt;String&gt; values = new ArrayList&lt;&gt;(max);for (int i = 0; i &lt; max; i++) &#123; UUID uuid = UUID.randomUUID(); values.add(uuid.toString());&#125; Now we measure the time it takes to sort a stream of this collection. Sequential Sort1234567891011long t0 = System.nanoTime();long count = values.stream().sorted().count();System.out.println(count);long t1 = System.nanoTime();long millis = TimeUnit.NANOSECONDS.toMillis(t1 - t0);System.out.println(String.format(\"sequential sort took: %d ms\", millis));// sequential sort took: 899 ms Parallel Sort1234567891011long t0 = System.nanoTime();long count = values.parallelStream().sorted().count();System.out.println(count);long t1 = System.nanoTime();long millis = TimeUnit.NANOSECONDS.toMillis(t1 - t0);System.out.println(String.format(\"parallel sort took: %d ms\", millis));// parallel sort took: 472 ms As you can see both code snippets are almost identical but the parallel sort is roughly 50% faster. All you have to do is change stream() to parallelStream(). Maps Map不能直接转化成Stream，map.keySet().stream(), map.values().stream() and map.entrySet().stream(). Map1234567Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;();for (int i = 0; i &lt; 10; i++) &#123; map.putIfAbsent(i, \"val\" + i);&#125;map.forEach((id, val) -&gt; System.out.println(val)); 1234567891011map.computeIfPresent(3, (num, val) -&gt; val + num);map.get(3); // val33map.computeIfPresent(9, (num, val) -&gt; null);map.containsKey(9); // falsemap.computeIfAbsent(23, num -&gt; \"val\" + num);map.containsKey(23); // truemap.computeIfAbsent(3, num -&gt; \"bam\");map.get(3); // val33 Next, we learn how to remove entries for a given key, only if it’s currently mapped to a given value: 12345map.remove(3, \"val3\");map.get(3); // val33map.remove(3, \"val33\");map.get(3); // null Another helpful method: 1map.getOrDefault(42, \"not found\"); // not found Merging entries of a map is quite easy: 12345map.merge(9, \"val9\", (value, newValue) -&gt; value.concat(newValue));map.get(9); // val9map.merge(9, \"concat\", (value, newValue) -&gt; value.concat(newValue));map.get(9); // val9concat Merge either put the key/value into the map if no entry for the key exists, or the merging function will be called to change the existing value. Date APIJava 8 引入新的日期和时间接口， java.time.新的日期接口与Joda-Time library 兼容, however it’s not the same. ClockClock 提供当前的时间和日期，是带时区的。 可以替代 System.currentTimeMillis() 。 Instant表示即使时间，可以转 java.util.Date objects. 12345Clock clock = Clock.systemDefaultZone();long millis = clock.millis();Instant instant = clock.instant();Date legacyDate = Date.from(instant); // legacy java.util.Date Timezones12345678910System.out.println(ZoneId.getAvailableZoneIds());// prints all available timezone idsZoneId zone1 = ZoneId.of(\"Europe/Berlin\");ZoneId zone2 = ZoneId.of(\"Brazil/East\");System.out.println(zone1.getRules());System.out.println(zone2.getRules());// ZoneRules[currentStandardOffset=+01:00]// ZoneRules[currentStandardOffset=-03:00] LocalTime12345678910LocalTime now1 = LocalTime.now(zone1);LocalTime now2 = LocalTime.now(zone2);System.out.println(now1.isBefore(now2)); // falselong hoursBetween = ChronoUnit.HOURS.between(now1, now2);long minutesBetween = ChronoUnit.MINUTES.between(now1, now2);System.out.println(hoursBetween); // -3System.out.println(minutesBetween); // -239 12345678910LocalTime late = LocalTime.of(23, 59, 59);System.out.println(late); // 23:59:59DateTimeFormatter germanFormatter = DateTimeFormatter .ofLocalizedTime(FormatStyle.SHORT) .withLocale(Locale.GERMAN);LocalTime leetTime = LocalTime.parse(\"13:37\", germanFormatter);System.out.println(leetTime); // 13:37 LocalDate1234567LocalDate today = LocalDate.now();LocalDate tomorrow = today.plus(1, ChronoUnit.DAYS);LocalDate yesterday = tomorrow.minusDays(2);LocalDate independenceDay = LocalDate.of(2014, Month.JULY, 4);DayOfWeek dayOfWeek = independenceDay.getDayOfWeek();System.out.println(dayOfWeek); // FRIDAY 1234567DateTimeFormatter germanFormatter = DateTimeFormatter .ofLocalizedDate(FormatStyle.MEDIUM) .withLocale(Locale.GERMAN);LocalDate xmas = LocalDate.parse(\"24.12.2014\", germanFormatter);System.out.println(xmas); // 2014-12-24 LocalDateTime12345678910LocalDateTime sylvester = LocalDateTime.of(2014, Month.DECEMBER, 31, 23, 59, 59);DayOfWeek dayOfWeek = sylvester.getDayOfWeek();System.out.println(dayOfWeek); // WEDNESDAYMonth month = sylvester.getMonth();System.out.println(month); // DECEMBERlong minuteOfDay = sylvester.getLong(ChronoField.MINUTE_OF_DAY);System.out.println(minuteOfDay); // 1439 123456Instant instant = sylvester .atZone(ZoneId.systemDefault()) .toInstant();Date legacyDate = Date.from(instant);System.out.println(legacyDate); // Wed Dec 31 23:59:59 CET 2014 1234567DateTimeFormatter formatter = DateTimeFormatter .ofPattern(\"MMM dd, yyyy - HH:mm\");LocalDateTime parsed = LocalDateTime.parse(\"Nov 03, 2014 - 07:13\", formatter);String string = formatter.format(parsed);System.out.println(string); // Nov 03, 2014 - 07:13 Unlike java.text.NumberFormat the new DateTimeFormatter is immutable and thread-safe. AnnotationsAnnotations in Java 8 are repeatable. Let’s dive directly into an example to figure that out. First, we define a wrapper annotation which holds an array of the actual annotations: 12345678@interface Hints &#123; Hint[] value();&#125;@Repeatable(Hints.class)@interface Hint &#123; String value();&#125; Java 8 enables us to use multiple annotations of the same type by declaring the annotation @Repeatable. Variant 1: Using the container annotation (old school)12@Hints(&#123;@Hint(\"hint1\"), @Hint(\"hint2\")&#125;)class Person &#123;&#125; Variant 2: Using repeatable annotations (new school)123@Hint(\"hint1\")@Hint(\"hint2\")class Person &#123;&#125; Using variant 2 the java compiler implicitly sets up the @Hints annotation under the hood. That’s important for reading annotation information via reflection. 12345678Hint hint = Person.class.getAnnotation(Hint.class);System.out.println(hint); // nullHints hints1 = Person.class.getAnnotation(Hints.class);System.out.println(hints1.value().length); // 2Hint[] hints2 = Person.class.getAnnotationsByType(Hint.class);System.out.println(hints2.length); // 2 Although we never declared the @Hints annotation on the Person class, it’s still readable via getAnnotation(Hints.class). However, the more convenient method is getAnnotationsByType which grants direct access to all annotated @Hint annotations. Furthermore the usage of annotations in Java 8 is expanded to two new targets: 12@Target(&#123;ElementType.TYPE_PARAMETER, ElementType.TYPE_USE&#125;)@interface MyAnnotation &#123;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://zhangliting.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://zhangliting.github.io/tags/Java/"}]},{"title":"Java面试题（1）","slug":"Java面试题（1）","date":"2017-04-17T17:22:48.000Z","updated":"2017-04-19T13:24:37.000Z","comments":true,"path":"2017/04/18/Java面试题（1）/","link":"","permalink":"http://zhangliting.github.io/2017/04/18/Java面试题（1）/","excerpt":"Java 面试题(1) 创建不可修改的对象 不提供setter方法 实例变量声明private final final class 修饰类，防止继承 方法返回时，final修饰的实例变量可以直接返回，否则返回copy。 不可变对象的优点 方便创建、使用和测试。 线程安全的（String） 适合作为Map和Set的Key。 允许hashcode延迟初始化和缓存","text":"Java 面试题(1) 创建不可修改的对象 不提供setter方法 实例变量声明private final final class 修饰类，防止继承 方法返回时，final修饰的实例变量可以直接返回，否则返回copy。 不可变对象的优点 方便创建、使用和测试。 线程安全的（String） 适合作为Map和Set的Key。 允许hashcode延迟初始化和缓存 example 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import java.util.Date; /*** Always remember that your instance variables will be either mutable or immutable.* Identify them and return new objects with copied content for all mutable objects.* Immutable variables can be returned safely without extra effort.* */public final class ImmutableClass&#123; /** * Integer class is immutable as it does not provide any setter to change its content * */ private final Integer immutableField1; /** * String class is immutable as it also does not provide setter to change its content * */ private final String immutableField2; /** * Date class is mutable as it provide setters to change various date/time parts * */ private final Date mutableField; //Default private constructor will ensure no unplanned construction of class private ImmutableClass(Integer fld1, String fld2, Date date) &#123; this.immutableField1 = fld1; this.immutableField2 = fld2; this.mutableField = new Date(date.getTime()); &#125; //Factory method to store object creation logic in single place public static ImmutableClass createNewInstance(Integer fld1, String fld2, Date date) &#123; return new ImmutableClass(fld1, fld2, date); &#125; //Provide no setter methods /** * Integer class is immutable so we can return the instance variable as it is * */ public Integer getImmutableField1() &#123; return immutableField1; &#125; /** * String class is also immutable so we can return the instance variable as it is * */ public String getImmutableField2() &#123; return immutableField2; &#125; /** * Date class is mutable so we need a little care here. * We should not return the reference of original instance variable. * Instead a new Date object, with content copied to it, should be returned. * */ public Date getMutableField() &#123; return new Date(mutableField.getTime()); &#125; @Override public String toString() &#123; return immutableField1 +\" - \"+ immutableField2 +\" - \"+ mutableField; &#125;&#125; Java是引用传递?值传递？ everything in java is pass-by-value example123456789101112131415161718192021222324252627282930public class Foo&#123; private String attribute; public Foo (String a)&#123; this.attribute = a; &#125; public String getAttribute() &#123; return attribute; &#125; public void setAttribute(String attribute) &#123; this.attribute = attribute; &#125;&#125; public class Main&#123; public static void main(String[] args)&#123; Foo f = new Foo(\"f\"); changeReference(f); // It won't change the reference! modifyReference(f); // It will change the object that the reference variable \"f\" refers to! &#125; public static void changeReference(Foo a) &#123; Foo b = new Foo(\"b\"); a = b; &#125; public static void modifyReference(Foo c) &#123; c.setAttribute(\"c\"); &#125;&#125; 在函数中，虚参是实参的拷贝，它们指向同一个对象，改变虚参的引用，并不会改变实参的引用，但是改变虚参指向的对象的属性，会同时改变实参指向的对象的属性。 finally 关键字 finally总是在try后执行。 finally不只用于处理异常，更适合处理资源的回收和代码清理工作。 JVM异常退出时，finally不一定会执行。 java.util.Date VS java.sql.Date java.util.Date == java.sql.Date + java.sql.Time java.sql.Date extend java.util.Date 标签接口（marker interface） It provices means to associate metadata with class where the languages does not hava explicit support for such metadata.一个类实现了标签接口，代表具有某种能力。 exampleSerializable Cloneable main方法为什么声明为public static voidpublic需要任何地方，任何对象都可以访问，因为它是程序的入口。static如果不是static，就需要创建对象，而且main传递可变参数，就会存在参数重载，就不知道那个main方法。voidJVM调用main方法不需要接受返回参数。可以使用System.exit(int)告诉JVM是否正常退出。0-正常。 创建String：new() 和 字面量的区别 new() 会同时在JVM heap和字符串常量池（JVM heap的永久区）里创建，而字面量只在后者创建。 example12String str = \"abc\";//if string pool exist \"abc\", reuse this, or add to string pool.String str = new String(\"abc\");//create \"abc\" in string pool if not exist, and create obj in heap too.(two objects created) 123String str = new String(\"abc\");// force use string poolstr.intern(); 为什么String是不可变的 提高性能（string pool, reuse） 安全考虑（thread security, memory leak issues） String比较 == 比较对象引用，同一个对象或者同一个strig pool的引用，返回true。 equals 被String覆写，比较字符的ascii值。 Menory leak issueString对象使用substring(int beginIndex) 创建对象的时候，value[]不会变，只改变了字符串开始和结束的索引。引起内存的浪费。substring12345678910/** The value is used for character storage. */private final char value[];To access this array in different scenarios, following variables are used:/** The offset is the first index of the storage that is used. */private final int offset;/** The count is the number of characters in the String. */private final int count; example12345678910111213141516171819202122232425import java.lang.reflect.Field;import java.util.Arrays; public class SubStringTest &#123; public static void main(String[] args) throws Exception &#123; //Our main String String mainString = \"i_love_java\"; //Substring holds value 'java' String subString = mainString.substring(7); System.out.println(mainString); System.out.println(subString); //Lets see what's inside mainString Field innerCharArray = String.class.getDeclaredField(\"value\"); innerCharArray.setAccessible(true); char[] chars = (char[]) innerCharArray.get(mainString); System.out.println(Arrays.toString(chars)); //Now peek inside subString chars = (char[]) innerCharArray.get(subString); System.out.println(Arrays.toString(chars)); &#125;&#125; 解决方法12345//Our new method prevents memory leakagepublic static String fancySubstring(int beginIndex, String original)&#123; return new String(original.substring(beginIndex));&#125; interface 和 abstract class 区别 interface中定义的变量都是public final，abstract class可以包含非final得变量。 interface中定义的方法都是public abstract抽象方法，abstract class可以有实现的方法。 interface using implements, abstract class using exntends。 Java类可以实现多个接口，但是只能继承一个父类（单继承）。 都不可以实例化。 什么时候覆写hashCode()和equals()方法hashCode()和equals()方法都是定义在Object类中。123456// return integer representation of memory address where object is storedpublic native int hashCode();// check reference of two objectspublic boolean equals(Object obj) &#123; return (this == obj);&#125; equals()必须是自反的，对称的和传递的。o.equals(null)始终返回false。 `equals()相等，那么hashCode()也保持相等。","categories":[{"name":"Java","slug":"Java","permalink":"http://zhangliting.github.io/categories/Java/"}],"tags":[{"name":"Java 面试","slug":"Java-面试","permalink":"http://zhangliting.github.io/tags/Java-面试/"}]},{"title":"HashMap原理","slug":"HashMap原理","date":"2017-04-17T16:58:37.000Z","updated":"2017-04-17T17:09:03.000Z","comments":true,"path":"2017/04/18/HashMap原理/","link":"","permalink":"http://zhangliting.github.io/2017/04/18/HashMap原理/","excerpt":"HashMap 工作原理 概念 hash算法，将任何变量或对象，计算一个唯一的值。 map, 将对象通过key,映射到值。examplehashmap使用内部类:Entry存数据。12345678static class Entry&lt;K, V&gt; implements Map.Entry&lt;K,V&gt;&#123;final K key;V value;Entry&lt;K, V&gt; next;// liek linkedListfinal int hash;// avoid computation everytime....//More code goes here&#125; table默认大小16。为了优化，size=2^N.举例：size=17, size-1=16。16=0…010000, and h &amp; (size-1) ，不管h是多少，结果只能是16 or 0.1234/** * The table, resized as necessary. Length MUST Always be a power of two. */transient Entry[] table; rehashes. avoid all data in the same index of array.1234567891011121314// the \"rehash\" function in JAVA 7 that takes the hashcode of the keystatic int hash(int h) &#123; h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12); return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);&#125;// the \"rehash\" function in JAVA 8 that directly takes the keystatic final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16); &#125;// the function that returns the index from the rehashed hashstatic int indexFor(int h, int length) &#123; return h &amp; (length-1);//取模运算的优化&#125;","text":"HashMap 工作原理 概念 hash算法，将任何变量或对象，计算一个唯一的值。 map, 将对象通过key,映射到值。examplehashmap使用内部类:Entry存数据。12345678static class Entry&lt;K, V&gt; implements Map.Entry&lt;K,V&gt;&#123;final K key;V value;Entry&lt;K, V&gt; next;// liek linkedListfinal int hash;// avoid computation everytime....//More code goes here&#125; table默认大小16。为了优化，size=2^N.举例：size=17, size-1=16。16=0…010000, and h &amp; (size-1) ，不管h是多少，结果只能是16 or 0.1234/** * The table, resized as necessary. Length MUST Always be a power of two. */transient Entry[] table; rehashes. avoid all data in the same index of array.1234567891011121314// the \"rehash\" function in JAVA 7 that takes the hashcode of the keystatic int hash(int h) &#123; h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12); return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);&#125;// the \"rehash\" function in JAVA 8 that directly takes the keystatic final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16); &#125;// the function that returns the index from the rehashed hashstatic int indexFor(int h, int length) &#123; return h &amp; (length-1);//取模运算的优化&#125; Put方法解析123456789101112131415161718192021222324252627282930313233/*** Associates the specified value with the specified key in this map. If the* map previously contained a mapping for the key, the old value is* replaced.** @param key* key with which the specified value is to be associated* @param value* value to be associated with the specified key* @return the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or &lt;tt&gt;null&lt;/tt&gt;* if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;. (A &lt;tt&gt;null&lt;/tt&gt; return* can also indicate that the map previously associated* &lt;tt&gt;null&lt;/tt&gt; with &lt;tt&gt;key&lt;/tt&gt;.)*/public V put(K key, V value) &#123; if (key == null) return putForNullKey(value); int hash = hash(key.hashCode()); int i = indexFor(hash, table.length); for (Entry&lt;K , V&gt; e = table[i]; e != null; e = e.next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; modCount++; addEntry(hash, key, value, i); return null;&#125; if (key == null) put table[0].// hash(null) == 0. object.hashCode()计算对象的hash值，再使用HashMap的hash()避免所有数据都是一个的hash值。 indexFor(hash, table.length)计算具体的索引。 HashMap内部是一个数组，每个一个元素是一个Entry(LinkedList)。如果当前索引已经有值，遍历当前的Entry，判断 key.equals(k) ，如果是true,replace value. 否则就检查Entry的next, until Entry.next == null, store value 12345678910111213141516st=&gt;startkey_is_null=&gt;condition: key != null?hashcode=&gt;operation: hashCode(),hash();indexFor=&gt;operation: indexFor();index=&gt;operation: indexFor();store=&gt;operation: put talbe[0];exist=&gt;condition: iterator, key.equals(k)?replace=&gt;operation: replace value;put=&gt;operation: put value;e=&gt;endst-&gt;key_is_nullkey_is_null(no)-&gt;store(right)-&gt;ekey_is_null(yes)-&gt;hashcode-&gt;indexFor-&gt;existexist(yes)-&gt;replace-&gt;eexist(no,left)-&gt;put(right)-&gt;e get()方法解析1234567891011121314151617181920212223242526272829/*** Returns the value to which the specified key is mapped, or &#123;@code null&#125;* if this map contains no mapping for the key.** &lt;p&gt;* More formally, if this map contains a mapping from a key &#123;@code k&#125; to a* value &#123;@code v&#125; such that &#123;@code (key==null ? k==null :* key.equals(k))&#125;, then this method returns &#123;@code v&#125;; otherwise it returns* &#123;@code null&#125;. (There can be at most one such mapping.)** &lt;/p&gt;&lt;p&gt;* A return value of &#123;@code null&#125; does not &lt;i&gt;necessarily&lt;/i&gt; indicate that* the map contains no mapping for the key; it's also possible that the map* explicitly maps the key to &#123;@code null&#125;. The &#123;@link #containsKey* containsKey&#125; operation may be used to distinguish these two cases.** @see #put(Object, Object)*/public V get(Object key) &#123; if (key == null) return getForNullKey(); int hash = hash(key.hashCode()); for (Entry&lt;K , V&gt; e = table[indexFor(hash, table.length)]; e != null; e = e.next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) return e.value; &#125; return null;&#125; if key == null, 返回talbe[0]。 根据hash(key.hashCode()),indexFor()找到entry。 遍历entry，找到key.equals(k), or return null HashMap初始容量HashMap初始容量是16，如果有16000条数据，平均每次get()，put()，remove()需要遍历1000次。所以需要合理的初始化容量。1public HashMap(int initialCapacity, float loadFactor) size: the size of key-value store in hashmap.threshold: threshold = capacity * loadFactor. 当put()时候，检查size&gt; threshold，如果是true，自动扩大2倍容量。并且重新分配。 HashMap是线程不安全的 因为存在自动扩容，现存可能获得扩容前的索引，导致拿到的错误数据。 两个现存同时扩容，可能引起死循环。 方案： [ ] HashTable：CRUD使用synchronized，不是高效的。 [X] ConcurrentHashMap：只synchronized buckets(Entry),如果hash不一样，就不会影响效率。 Java 8 优化HashMap当TREEIFY_THRESHOLD &gt; 8 时，bucket就会从likedList转变成balanced tree（红黑树）。当UNTREEIFY_THRESHOLD 《 6时，bucket就会从balanced tree转变成linkedList`。性能：O(n) -&gt; O(logn) (空间也会增加)123456static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; final K key; V value; Node&lt;K,V&gt; next;//Node replace Entry. ... java123456789101112static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; &#123; final int hash; // inherited from Node&lt;K,V&gt; final K key; // inherited from Node&lt;K,V&gt; V value; // inherited from Node&lt;K,V&gt; Node&lt;K,V&gt; next; // inherited from Node&lt;K,V&gt; Entry&lt;K,V&gt; before, after;// inherited from LinkedHashMap.Entry&lt;K,V&gt; TreeNode&lt;K,V&gt; parent; TreeNode&lt;K,V&gt; left; TreeNode&lt;K,V&gt; right; TreeNode&lt;K,V&gt; prev; boolean red; ... 因为TreeNode extends LinkedHashMap.Entry。所以可以使用原来的Entry. 优化建议 使用合适的hashCode()减少冲突。 合理初始化HashMap容量，避免resize。默认16*0.75=12，当插入12th时，扩容。","categories":[{"name":"HashMap","slug":"HashMap","permalink":"http://zhangliting.github.io/categories/HashMap/"}],"tags":[{"name":"HashMap","slug":"HashMap","permalink":"http://zhangliting.github.io/tags/HashMap/"}]},{"title":"黑客与画家书摘","slug":"黑客与画家书摘","date":"2017-04-17T16:58:14.000Z","updated":"2017-04-17T17:09:42.000Z","comments":true,"path":"2017/04/18/黑客与画家书摘/","link":"","permalink":"http://zhangliting.github.io/2017/04/18/黑客与画家书摘/","excerpt":"黑客与画家 保罗.格雷厄 创业公式 搭建原型 上线运营（别管bug） 收集反馈 调整产品 成长壮大","text":"黑客与画家 保罗.格雷厄 创业公式 搭建原型 上线运营（别管bug） 收集反馈 调整产品 成长壮大 Cool Hack 好玩 高智商 探索精神 黑客理论（hacker ethic） 使用计算机以及所有有助于了解这个世界本质的事物都不应受到任何限制。任何事情都应该亲手尝试。(Access to computers-and anything that might teach you something about the way the world works-should be unlimited and total.Always yiled to the Hands-On Imperative!) 信息应该全部免费。(All information should be free) 不信任权威，提倡去中心化。(Mistrust Authority-Promote Decentralization) 判断一名黑客的水平应该看他的技术能力，而不是看他的学历、年龄或者地位等其他标准。(Hackers should be judged by their hacking, not bogus cariteria such as degrees,age,race,or position.) 你可以用计算机创造美和艺术。(You can create art and beauty on a computer) 计算机使生活更美好。(Computers can change your life for the better) 黑客与画家的相似 都是创作者。 画家的修改与黑客的调试。 都作自己爱做的事。 都是通过实践和借鉴学习。 编程语言就像画家手里的颜料，都是创作工具。 画家对画的细节一丝不苟的追求，和黑客对优秀软件美的狂热的追求。 都学要灵感去创作。 都是满足人的需求。 都很酷。 摘要黑客 黑客通过实践学习编程。 开发优秀软件的方法之一就是自己创业。 真正竞争软件设计的战场是新兴领域的市场，这里还没有人建立过防御工事。只要你能做出大胆的设计，就能在这里战胜大公司。 创作者另一个学习的途径是通过范例。同样地，黑客通过观看优秀的程序学会编程。 看不见的细节累加起来，就变得可见了。 如果黑客只是一个负责实现领导意志的技术工人，指责就是根据规格说明书写出代码，那么他其实与一个挖水沟的工人没什么区别。 正确的合作方法是将项目分割成严格定义的模块，每个模块由一个人明确负责。模块之间的接口经过精心的设计，如果可能的话，最好把文档说明写的像编程语言规范那样清晰。 从他人的角度思考问题是成功的奥秘所在。 程序写出来时给人看的，附带能在机器上运行。 正是那些不服从管教的人们，才是美国财富与力量的源泉。 只有深入了解当前的技术，黑客才能构想下一代技术。 另一条路 设计桌面软件就像设计一幢大楼，而设计互联网软件就像设计一座城市。 不同的语言适合不同的任务，你应该根据不同的场合，挑选最合适的工具。 如果你是一个黑客，并且梦想自己创业，可能会有两件事情令你望而却步，一件是你不懂得企业管理，另一件是你害怕竞争。管理企业其实很简单，只要记住两点就可以了：做出用户喜欢的产品，保证开支小于收入。 只有懂得设计的黑客，才能设计软件，不能交给对软件一知半解的设计师。 如何创造财富 致富，最好的办法就是自己创业，或者加入创业公司。 创造财富的法则，如果你想赚100万美元，就不得不忍受相当于100万美元的痛苦。 创造有价值的东西就是创造财富。 财富是人们需要的东西，是有价值的东西。 要财富，你需要两样东西：可测量性和可放大性。你的职位产生的业绩，应该是可测量的，否则你做的再多，也不会得到更多的报酬。此外，你还必须有可放大性，也就是说你做出的决定能够产生巨大的效应。 收入和风险是对称的，如果你有一个令你感到安全的工作，你是不会致富的，因为没有危险就没有放大性。 小团体 = 可测量性 高科技 = 可放大性 如果你知道某种东西的发明人，那时因为他的公司用这种发明赚到了钱，并求公司的公关人员尽力散步发明人的故事。 故意选择较困难的技术问题，给竞争对手设置壁垒，其他人复制你的模式就会很困难。 如果有两个选择，就选较难的那个。 要鼓励大家去创业。只要懂得藏富于民，国家就会变得强大。让书呆子保住他们的血汗钱，你就会无敌于天下。 设计者的品位 优秀作品的秘诀就是：非常严格的品位，再加上实现这种品位的能力。 好设计是简单的设计。 好设计是永不过时的设计。 好设计是解决主要问题的设计。 好设计是启发性的设计。 好设计通常是有点趣味性的设计。 好设计是艰苦的设计。 好设计是看似容易的设计。 好设计是对称的设计。 好设计是模仿大自然的设计。 好设计是一种再设计。 好设计是能够复制的设计。 好设计常常是奇特的设计。 好设计是成批出现的。 好设计常常是大胆的设计。 编程语言 一个操作所需要的代码越多，就越难避免bug，也越难发现它们。","categories":[{"name":"书摘","slug":"书摘","permalink":"http://zhangliting.github.io/categories/书摘/"}],"tags":[{"name":"书摘","slug":"书摘","permalink":"http://zhangliting.github.io/tags/书摘/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-04-17T16:42:34.501Z","updated":"2017-03-27T16:06:25.000Z","comments":true,"path":"2017/04/18/hello-world/","link":"","permalink":"http://zhangliting.github.io/2017/04/18/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"MongoDB in practice","slug":"MongoDB-in-practice","date":"2017-04-11T18:33:25.000Z","updated":"2017-04-17T17:02:13.846Z","comments":true,"path":"2017/04/12/MongoDB-in-practice/","link":"","permalink":"http://zhangliting.github.io/2017/04/12/MongoDB-in-practice/","excerpt":"#MongoDB in Priactice 1. install安装路径 G:\\Tools\\MongoDB 2. onfig新建mongodb.config放到G:\\Tools\\MongoDB\\bin内容 12345## 数据库文件目录 dbpath=G:/Tools/MongoDB/data ## 日志目录 logpath=G:/Tools/MongoDB/log/mongo.log diaglog=3","text":"#MongoDB in Priactice 1. install安装路径 G:\\Tools\\MongoDB 2. onfig新建mongodb.config放到G:\\Tools\\MongoDB\\bin内容 12345## 数据库文件目录 dbpath=G:/Tools/MongoDB/data ## 日志目录 logpath=G:/Tools/MongoDB/log/mongo.log diaglog=3 3. start mongodbmongod --config g:\\Tools\\MongoDB\\bin\\mongodb.config将MongoDB服务器作为Windows服务运行mongod --config g:\\Tools\\MongoDB\\bin\\mongodb.config --install 4. connect mongodbmongowe can use robomongo to operator mongodb with GUI 5. Spring Support1. use springdata JAP 123456public interface PersonDao extends MongoRepository&lt;Person, ObjectId&gt; &#123; @Query(value = \"&#123;'age' : &#123;'$gte' : ?0, '$lte' : ?1&#125;, 'name':?2 &#125;\",fields=\"&#123; 'name' : 1, 'age' : 1&#125;\") List&lt;Person&gt; findByAge(int age1, int age2, String name);&#125; 2. use mongoTemplate 12345678910111213141516171819202122232425262728293031@Repository(\"personMongoImpl\")public class PersonMongoImpl implements PersonMongoDao &#123; @Resource private MongoTemplate mongoTemplate; @Override public List&lt;Person&gt; findAll() &#123; return mongoTemplate.findAll(Person.class,\"person\"); &#125; @Override public void insertPerson(Person person) &#123; mongoTemplate.insert(person,\"person\"); &#125; @Override public void removePerson(String userName) &#123; mongoTemplate.remove(Query.query(Criteria.where(\"name\").is(userName)),\"person\"); &#125; @Override public void updatePerson() &#123; mongoTemplate.updateMulti(Query.query(Criteria.where(\"age\").gt(3).lte(5)), Update.update(\"age\",3),\"person\"); &#125; @Override public List&lt;Person&gt; findForRequery(String userName) &#123; return mongoTemplate.find(Query.query(Criteria.where(\"name\").is(userName)),Person.class); &#125;&#125;","categories":[{"name":"MongoDB","slug":"MongoDB","permalink":"http://zhangliting.github.io/categories/MongoDB/"}],"tags":[{"name":"MongoDB","slug":"MongoDB","permalink":"http://zhangliting.github.io/tags/MongoDB/"}]},{"title":"数据结构基础","slug":"数据结构基础","date":"2017-04-11T15:19:55.000Z","updated":"2017-04-11T14:29:33.000Z","comments":true,"path":"2017/04/11/数据结构基础/","link":"","permalink":"http://zhangliting.github.io/2017/04/11/数据结构基础/","excerpt":"原文地址：github.com/kdn251/interviews 译文出自：掘金翻译计划 译者：王下邀月熊 校对者：PhxNirvana、根号三 这个 链接 用来查看本翻译与英文版是否有差别（如果你没有看到 README.md 发生变化，那就意味着这份翻译文档是最新的）。 Interviews 软件工程技术面试个人指南。 Maintainer - Kevin Naughton Jr. 其他语言版本 English 目录 在线练习 在线面试编程 数据结构 算法 位运算 算法复杂度分析 视频教程 面试书籍 计算机科学与技术资讯 文件结构 在线练习 LeetCode Virtual Judge CareerCup HackerRank CodeFights Kattis HackerEarth 在线面试编程 Gainlo Refdash","text":"原文地址：github.com/kdn251/interviews 译文出自：掘金翻译计划 译者：王下邀月熊 校对者：PhxNirvana、根号三 这个 链接 用来查看本翻译与英文版是否有差别（如果你没有看到 README.md 发生变化，那就意味着这份翻译文档是最新的）。 Interviews 软件工程技术面试个人指南。 Maintainer - Kevin Naughton Jr. 其他语言版本 English 目录 在线练习 在线面试编程 数据结构 算法 位运算 算法复杂度分析 视频教程 面试书籍 计算机科学与技术资讯 文件结构 在线练习 LeetCode Virtual Judge CareerCup HackerRank CodeFights Kattis HackerEarth 在线面试编程 Gainlo Refdash 数据结构Linked List 链表即是由节点（Node）组成的线性集合，每个节点可以利用指针指向其他节点。它是一种包含了多个节点的、能够用于表示序列的数据结构。 单向链表: 链表中的节点仅指向下一个节点，并且最后一个节点指向空。 双向链表: 其中每个节点具有两个指针 p、n，使得 p 指向先前节点并且 n 指向下一个节点；最后一个节点的 n 指针指向 null。 循环链表：每个节点指向下一个节点并且最后一个节点指向第一个节点的链表。 时间复杂度: 索引: O(n) 搜索: O(n) 插入: O(1) 移除: O(1) Stack 栈是元素的集合，其包含了两个基本操作：push 操作可以用于将元素压入栈，pop 操作可以将栈顶元素移除。 遵循后入先出（LIFO）原则。 时间复杂度: 索引: O(n) 搜索: O(n) 插入: O(1) 移除: O(1) Queue 队列是元素的集合，其包含了两个基本操作：enqueue 操作可以用于将元素插入到队列中，而 dequeeu 操作则是将元素从队列中移除。 遵循先入先出原则 (FIFO)。 时间复杂度: 索引: O(n) 搜索: O(n) 插入: O(1) 移除: O(1) Tree 树是无向、连通的无环图。 Binary Tree 二叉树即是每个节点最多包含左子节点与右子节点这两个节点的树形数据结构。 满二叉树: 树中的每个节点仅包含 0 或 2 个节点。 完美二叉树（Perfect Binary Tree）: 二叉树中的每个叶节点都拥有两个子节点，并且具有相同的高度。 完全二叉树: 除最后一层外，每一层上的结点数均达到最大值；在最后一层上只缺少右边的若干结点。 Binary Search Tree 二叉搜索树（BST）是一种特殊的二叉树，其任何节点中的值都会大于或者等于其左子树中存储的值并且小于或者等于其右子树中存储的值。 时间复杂度: 索引: O(log(n)) 搜索: O(log(n)) 插入: O(log(n)) 删除: O(log(n)) Trie 字典树，又称基数树或者前缀树，能够用于存储键为字符串的动态集合或者关联数组的搜索树。树中的节点并没有直接存储关联键值，而是该节点在树中的挂载位置决定了其关联键值。某个节点的所有子节点都拥有相同的前缀，整棵树的根节点则是空字符串。 Fenwick Tree 树状数组又称 Binary Indexed Tree，其表现形式为树，不过本质上是以数组实现。数组中的下标代表着树中的顶点，每个顶点的父节点或者子节点的下标能够通过位运算获得。数组中的每个元素包含了预计算的区间值之和，在整棵树更新的过程中同样会更新这些预计算的值。 时间复杂度: 区间求值: O(log(n)) 更新: O(log(n)) Segment Tree 线段树是用于存放间隔或者线段的树形数据结构，它允许快速的查找某一个节点在若干条线段中出现的次数. 时间复杂度: 区间查询: O(log(n)) 更新: O(log(n)) Heap 堆是一种特殊的基于树的满足某些特性的数据结构，整个堆中的所有父子节点的键值都会满足相同的排序条件。堆更准确地可以分为最大堆与最小堆，在最大堆中，父节点的键值永远大于或者等于子节点的值，并且整个堆中的最大值存储于根节点；而最小堆中，父节点的键值永远小于或者等于其子节点的键值，并且整个堆中的最小值存储于根节点。 时间复杂度: 访问: O(log(n)) 搜索: O(log(n)) 插入: O(log(n)) 移除: O(log(n)) 移除最大值 / 最小值: O(1) Hashing 哈希能够将任意长度的数据映射到固定长度的数据。哈希函数返回的即是哈希值，如果两个不同的键得到相同的哈希值，即将这种现象称为碰撞。 Hash Map: Hash Map 是一种能够建立起键与值之间关系的数据结构，Hash Map 能够使用哈希函数将键转化为桶或者槽中的下标，从而优化对于目标值的搜索速度。 碰撞解决 链地址法（Separate Chaining）: 链地址法中，每个桶是相互独立的，包含了一系列索引的列表。搜索操作的时间复杂度即是搜索桶的时间（固定时间）与遍历列表的时间之和。 开地址法（Open Addressing）: 在开地址法中，当插入新值时，会判断该值对应的哈希桶是否存在，如果存在则根据某种算法依次选择下一个可能的位置，直到找到一个尚未被占用的地址。所谓开地址法也是指某个元素的位置并不永远由其哈希值决定。 Graph 图是一种数据元素间为多对多关系的数据结构，加上一组基本操作构成的抽象数据类型。 无向图（Undirected Graph）: 无向图具有对称的邻接矩阵，因此如果存在某条从节点 u 到节点 v 的边，反之从 v 到 u 的边也存在。 有向图（Directed Graph）: 有向图的邻接矩阵是非对称的，即如果存在从 u 到 v 的边并不意味着一定存在从 v 到 u 的边。 算法排序快速排序 稳定: 否 时间复杂度: 最优时间: O(nlog(n)) 最坏时间: O(n^2) 平均时间: O(nlog(n)) 归并排序 归并排序是典型的分治算法，它不断地将某个数组分为两个部分，分别对左子数组与右子数组进行排序，然后将两个数组合并为新的有序数组。 稳定: 是 时间复杂度: 最优时间: O(nlog(n)) 最坏时间: O(nlog(n)) 平均时间: O(nlog(n)) 桶排序 桶排序将数组分到有限数量的桶子里。每个桶子再个别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序）。 时间复杂度: 最优时间: Ω(n + k) 最坏时间: O(n^2) 平均时间:Θ(n + k) 基数排序 基数排序类似于桶排序，将数组分割到有限数目的桶中；不过其在分割之后并没有让每个桶单独地进行排序，而是直接进行了合并操作。 时间复杂度: 最优时间: Ω(nk) 最坏时间: O(nk) 平均时间: Θ(nk) 图算法深度优先搜索 深度优先算法是一种优先遍历子节点而不是回溯的算法。 时间复杂度: O(|V| + |E|) 广度优先搜索 广度优先搜索是优先遍历邻居节点而不是子节点的图遍历算法。 时间复杂度: O(|V| + |E|) 拓扑排序 拓扑排序是对于有向图节点的线性排序，如果存在某条从 u 到 v 的边，则认为 u 的下标先于 v。 时间复杂度: O(|V| + |E|) Dijkstra 算法 Dijkstra 算法 用于计算有向图中单源最短路径问题。 时间复杂度: O(|V|^2) Bellman-Ford 算法 Bellman-Ford 算法是在带权图中计算从单一源点出发到其他节点的最短路径的算法。 尽管算法复杂度大于 Dijkstra 算法，但是它适用于包含了负值边的图。 时间复杂度: 最优时间: O(|E|) 最坏时间: O(|V||E|) Floyd-Warshall 算法 Floyd-Warshall 算法 能够用于在无环带权图中寻找任意节点的最短路径。 时间复杂度: 最优时间: O(|V|^3) 最坏时间: O(|V|^3) 平均时间: O(|V|^3) Prim 算法 Prim 算法是用于在带权无向图中计算最小生成树的贪婪算法。换言之，Prim 算法能够在图中抽取出连接所有节点的边的最小代价子集。 时间复杂度: O(|V|^2) Kruskal 算法 Kruskal 算法同样是计算图的最小生成树的算法，与 Prim 的区别在于并不需要图是连通的。 时间复杂度: O(|E|log|V|) 位运算 位运算即是在位级别进行操作的技术，合适的位运算能够帮助我们得到更快地运算速度与更小的内存使用。 测试第 k 位: s &amp; (1 &lt;&lt; k) 设置第 k 位: s |= (1 &lt;&lt; k) 第 k 位置零: s &amp;= ~(1 &lt;&lt; k) 切换第 k 位值: s ^= ~(1 &lt;&lt; k) 乘以 2: s &lt;&lt; n 除以 2: s &gt;&gt; n 交集: s &amp; t 并集: s | t 减法: s &amp; ~t 交换 x = x ^ y ^ (y = x) 取出最小非 0 位（Extract lowest set bit）: s &amp; (-s) 取出最小 0 位（Extract lowest unset bit）: ~s &amp; (s + 1) 交换值:123x ^= y;y ^= x;x ^= y; 算法复杂度分析大 O 表示 大 O 表示 用于表示某个算法的上限，往往用于描述最坏的情况。 小 O 表示 小 O 表示用于描述某个算法的渐进上界，不过二者要更为紧密。 大 Ω 表示 大 Ω 表示用于描述某个算法的渐进下界。 小 ω 表示 Little Omega Notation用于描述某个特定算法的下界，不过不一定很靠近。 Theta Θ 表示 Theta Notation用于描述某个确定算法的确界。 视频教程 Data Structures UC Berkeley Data Structures MIT Advanced Data Structures Algorithms MIT Introduction to Algorithms MIT Advanced Algorithms 面试书籍 Competitive Programming 3 - Steven Halim &amp; Felix Halim Cracking The Coding Interview - Gayle Laakmann McDowell Cracking The PM Interview - Gayle Laakmann McDowell &amp; Jackie Bavaro 计算机科学与技术资讯 Hacker News Lobsters 文件结构123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145.├── Array│ ├── bestTimeToBuyAndSellStock.java│ ├── findTheCelebrity.java│ ├── gameOfLife.java│ ├── increasingTripletSubsequence.java│ ├── insertInterval.java│ ├── longestConsecutiveSequence.java│ ├── maximumProductSubarray.java│ ├── maximumSubarray.java│ ├── mergeIntervals.java│ ├── missingRanges.java│ ├── productOfArrayExceptSelf.java│ ├── rotateImage.java│ ├── searchInRotatedSortedArray.java│ ├── spiralMatrixII.java│ ├── subsetsII.java│ ├── subsets.java│ ├── summaryRanges.java│ ├── wiggleSort.java│ └── wordSearch.java├── Backtracking│ ├── androidUnlockPatterns.java│ ├── generalizedAbbreviation.java│ └── letterCombinationsOfAPhoneNumber.java├── BinarySearch│ ├── closestBinarySearchTreeValue.java│ ├── firstBadVersion.java│ ├── guessNumberHigherOrLower.java│ ├── pow(x,n).java│ └── sqrt(x).java├── BitManipulation│ ├── binaryWatch.java│ ├── countingBits.java│ ├── hammingDistance.java│ ├── maximumProductOfWordLengths.java│ ├── numberOf1Bits.java│ ├── sumOfTwoIntegers.java│ └── utf-8Validation.java├── BreadthFirstSearch│ ├── binaryTreeLevelOrderTraversal.java│ ├── cloneGraph.java│ ├── pacificAtlanticWaterFlow.java│ ├── removeInvalidParentheses.java│ ├── shortestDistanceFromAllBuildings.java│ ├── symmetricTree.java│ └── wallsAndGates.java├── DepthFirstSearch│ ├── balancedBinaryTree.java│ ├── battleshipsInABoard.java│ ├── convertSortedArrayToBinarySearchTree.java│ ├── maximumDepthOfABinaryTree.java│ ├── numberOfIslands.java│ ├── populatingNextRightPointersInEachNode.java│ └── sameTree.java├── Design│ └── zigzagIterator.java├── DivideAndConquer│ ├── expressionAddOperators.java│ └── kthLargestElementInAnArray.java├── DynamicProgramming│ ├── bombEnemy.java│ ├── climbingStairs.java│ ├── combinationSumIV.java│ ├── countingBits.java│ ├── editDistance.java│ ├── houseRobber.java│ ├── paintFence.java│ ├── paintHouseII.java│ ├── regularExpressionMatching.java│ ├── sentenceScreenFitting.java│ ├── uniqueBinarySearchTrees.java│ └── wordBreak.java├── HashTable│ ├── binaryTreeVerticalOrderTraversal.java│ ├── findTheDifference.java│ ├── groupAnagrams.java│ ├── groupShiftedStrings.java│ ├── islandPerimeter.java│ ├── loggerRateLimiter.java│ ├── maximumSizeSubarraySumEqualsK.java│ ├── minimumWindowSubstring.java│ ├── sparseMatrixMultiplication.java│ ├── strobogrammaticNumber.java│ ├── twoSum.java│ └── uniqueWordAbbreviation.java├── LinkedList│ ├── addTwoNumbers.java│ ├── deleteNodeInALinkedList.java│ ├── mergeKSortedLists.java│ ├── palindromeLinkedList.java│ ├── plusOneLinkedList.java│ ├── README.md│ └── reverseLinkedList.java├── Queue│ └── movingAverageFromDataStream.java├── README.md├── Sort│ ├── meetingRoomsII.java│ └── meetingRooms.java├── Stack│ ├── binarySearchTreeIterator.java│ ├── decodeString.java│ ├── flattenNestedListIterator.java│ └── trappingRainWater.java├── String│ ├── addBinary.java│ ├── countAndSay.java│ ├── decodeWays.java│ ├── editDistance.java│ ├── integerToEnglishWords.java│ ├── longestPalindrome.java│ ├── longestSubstringWithAtMostKDistinctCharacters.java│ ├── minimumWindowSubstring.java│ ├── multiplyString.java│ ├── oneEditDistance.java│ ├── palindromePermutation.java│ ├── README.md│ ├── reverseVowelsOfAString.java│ ├── romanToInteger.java│ ├── validPalindrome.java│ └── validParentheses.java├── Tree│ ├── binaryTreeMaximumPathSum.java│ ├── binaryTreePaths.java│ ├── inorderSuccessorInBST.java│ ├── invertBinaryTree.java│ ├── lowestCommonAncestorOfABinaryTree.java│ ├── sumOfLeftLeaves.java│ └── validateBinarySearchTree.java├── Trie│ ├── addAndSearchWordDataStructureDesign.java│ ├── implementTrie.java│ └── wordSquares.java└── TwoPointers ├── 3Sum.java ├── 3SumSmaller.java ├── mergeSortedArray.java ├── minimumSizeSubarraySum.java ├── moveZeros.java ├── removeDuplicatesFromSortedArray.java ├── reverseString.java └── sortColors.java18 directories, 124 files","categories":[{"name":"算法","slug":"算法","permalink":"http://zhangliting.github.io/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://zhangliting.github.io/tags/算法/"},{"name":"数据结构","slug":"数据结构","permalink":"http://zhangliting.github.io/tags/数据结构/"}]},{"title":"MyBatis 入门","slug":"MyBatis-入门","date":"2017-03-28T15:12:47.000Z","updated":"2017-03-28T15:26:43.000Z","comments":true,"path":"2017/03/28/MyBatis-入门/","link":"","permalink":"http://zhangliting.github.io/2017/03/28/MyBatis-入门/","excerpt":"MyBatis 入门 安装12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;x.x.x&lt;/version&gt;&lt;/dependency&gt; 从XML中构建SqlSessionFactory123String resource = \"org/mybatis/example/mybatis-config.xml\";InputStream inputStream = Resources.getResourceAsStream(resource);sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);","text":"MyBatis 入门 安装12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;x.x.x&lt;/version&gt;&lt;/dependency&gt; 从XML中构建SqlSessionFactory123String resource = \"org/mybatis/example/mybatis-config.xml\";InputStream inputStream = Resources.getResourceAsStream(resource);sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); XML配置文件1234567891011121314151617181920&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;environments default=\"development\"&gt; &lt;environment id=\"development\"&gt; &lt;transactionManager type=\"JDBC\"/&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"$&#123;driver&#125;\"/&gt; &lt;property name=\"url\" value=\"$&#123;url&#125;\"/&gt; &lt;property name=\"username\" value=\"$&#123;username&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;password&#125;\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource=\"org/mybatis/example/BlogMapper.xml\"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 从 SqlSessionFactory 中获取123456SqlSessionSqlSession session = sqlSessionFactory.openSession();try &#123; Blog blog = (Blog) session.selectOne(\"org.mybatis.example.BlogMapper.selectBlog\", 101);&#125; finally &#123; session.close();&#125; Sql 映射123456789&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"org.mybatis.example.BlogMapper\"&gt; &lt;select id=\"selectBlog\" resultType=\"Blog\"&gt; select * from Blog where id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 接口映射12345package org.mybatis.example;public interface BlogMapper &#123; @Select(\"SELECT * FROM blog WHERE id = #&#123;id&#125;\") Blog selectBlog(int id);&#125; Mapper Interface1234567SqlSession session = sqlSessionFactory.openSession();try &#123; BlogMapper mapper = session.getMapper(BlogMapper.class); Blog blog = mapper.selectBlog(101);&#125; finally &#123; session.close();&#125; 作用域SqlSessionFactoryBuilder用于创建SqlSessionFacotry,只需要创建一次，每一个实例都要创建对应的SqlSesion。使用完必须关闭。","categories":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://zhangliting.github.io/categories/MyBatis/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://zhangliting.github.io/tags/MyBatis/"}]},{"title":"Java Bit 操作优化算法","slug":"Java-Bit-操作优化算法","date":"2017-03-27T14:04:09.000Z","updated":"2017-03-27T16:02:35.000Z","comments":true,"path":"2017/03/27/Java-Bit-操作优化算法/","link":"","permalink":"http://zhangliting.github.io/2017/03/27/Java-Bit-操作优化算法/","excerpt":"Java Bit 操作优化算法 基本操作符 &amp; 或 | 与 ^ 异或 ! 非 &lt;&lt; 左移 &gt;&gt; 右移 &gt;&gt;&gt; 无符号右移 Examples 统计1的bit个数1234567int count_one(int n) &#123; while(n) &#123; n = n&amp;(n-1); count++; &#125; return count;&#125;","text":"Java Bit 操作优化算法 基本操作符 &amp; 或 | 与 ^ 异或 ! 非 &lt;&lt; 左移 &gt;&gt; 右移 &gt;&gt;&gt; 无符号右移 Examples 统计1的bit个数1234567int count_one(int n) &#123; while(n) &#123; n = n&amp;(n-1); count++; &#125; return count;&#125; 判断是否4的N次方1234bool isPowerOfFour(int n) &#123; return !(n&amp;(n-1)) &amp;&amp; (n&amp;0x55555555); //check the 1-bit location;&#125; 计算和123int getSum(int a, int b) &#123; return b==0? a:getSum(a^b, (a&amp;b)&lt;&lt;1); //be careful about the terminating condition;&#125; 在0~N的数中找到缺少个一个数字12345678int missingNumber(vector&lt;int&gt;&amp; nums) &#123; int ret = 0; for(int i = 0; i &lt; nums.size(); ++i) &#123; ret ^= i; ret ^= nums[i]; &#125; return ret^=nums.size();&#125; 2的N次方&lt;=M,给定M，找打最大的数123456789long largest_power(long N) &#123; //changing all right side bits to 1. N = N | (N&gt;&gt;1); N = N | (N&gt;&gt;2); N = N | (N&gt;&gt;4); N = N | (N&gt;&gt;8); N = N | (N&gt;&gt;16); return (N+1)&gt;&gt;1;&#125; 反转bit123456789uint32_t reverseBits(uint32_t n) &#123; unsigned int mask = 1&lt;&lt;31, res = 0; for(int i = 0; i &lt; 32; ++i) &#123; if(n &amp; 1) res |= mask; mask &gt;&gt;= 1; n &gt;&gt;= 1; &#125; return res;&#125; 12345x = ((x &amp; 0xaaaaaaaa) &gt;&gt; 1) | ((x &amp; 0x55555555) &lt;&lt; 1);x = ((x &amp; 0xcccccccc) &gt;&gt; 2) | ((x &amp; 0x33333333) &lt;&lt; 2);x = ((x &amp; 0xf0f0f0f0) &gt;&gt; 4) | ((x &amp; 0x0f0f0f0f) &lt;&lt; 4);x = ((x &amp; 0xff00ff00) &gt;&gt; 8) | ((x &amp; 0x00ff00ff) &lt;&lt; 8);x = ((x &amp; 0xffff0000) &gt;&gt; 16) | ((x &amp; 0x0000ffff) &lt;&lt; 16);","categories":[{"name":"算法","slug":"算法","permalink":"http://zhangliting.github.io/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://zhangliting.github.io/tags/算法/"},{"name":"bit","slug":"bit","permalink":"http://zhangliting.github.io/tags/bit/"}]},{"title":"第三方支付平台设计","slug":"第三方支付平台设计","date":"2017-03-22T14:04:29.000Z","updated":"2017-04-18T15:02:12.000Z","comments":true,"path":"2017/03/22/第三方支付平台设计/","link":"","permalink":"http://zhangliting.github.io/2017/03/22/第三方支付平台设计/","excerpt":"第三方支付平台设计1234567891011121314st=&gt;start: Starts1=&gt;subroutine: 客户选购商品s2=&gt;subroutine: 商户提交支付订单s3=&gt;subroutine: 第三方支付平台处理s4=&gt;subroutine: 向银行发起扣款请求s5=&gt;subroutine: 返扣款付结果s6=&gt;subroutine: 返回商户显示购买成功s7=&gt;subroutine: 转发支付请求s8=&gt;subroutine: 客户输入支付卡号、密码cond=&gt;condition: 直连支付？ed=&gt;end: Endst-&gt;s1-&gt;s2-&gt;cond(yes)-&gt;s3-&gt;s4-&gt;s5-&gt;s6-&gt;edcond(no)-&gt;s7-&gt;s8-&gt;s5 &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD","text":"第三方支付平台设计1234567891011121314st=&gt;start: Starts1=&gt;subroutine: 客户选购商品s2=&gt;subroutine: 商户提交支付订单s3=&gt;subroutine: 第三方支付平台处理s4=&gt;subroutine: 向银行发起扣款请求s5=&gt;subroutine: 返扣款付结果s6=&gt;subroutine: 返回商户显示购买成功s7=&gt;subroutine: 转发支付请求s8=&gt;subroutine: 客户输入支付卡号、密码cond=&gt;condition: 直连支付？ed=&gt;end: Endst-&gt;s1-&gt;s2-&gt;cond(yes)-&gt;s3-&gt;s4-&gt;s5-&gt;s6-&gt;edcond(no)-&gt;s7-&gt;s8-&gt;s5 &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD 2060c955d6671c89822d8098dfa0d22d5a923c30","categories":[],"tags":[{"name":"支付","slug":"支付","permalink":"http://zhangliting.github.io/tags/支付/"}]},{"title":"阿里巴巴技术手册","slug":"阿里巴巴Java技术手册","date":"2017-03-21T15:26:23.000Z","updated":"2017-03-27T16:06:43.000Z","comments":true,"path":"2017/03/21/阿里巴巴Java技术手册/","link":"","permalink":"http://zhangliting.github.io/2017/03/21/阿里巴巴Java技术手册/","excerpt":"Java开发手册( 版本号 制作团队 更新日期 备注 1.0.0 阿里巴巴集团技术部 2016.12.7 首次公开 编程规约(一) 命名规约 【强制】类名使用UpperCamelCase风格，必须遵从驼峰形式，但以下情形例外：（领域模型的相关命名）DO / DTO / VO / DAO等。 正例：MarcoPolo / UserDO / XmlService / TcpUdpDeal / TaPromotion 反例：macroPolo / UserDo / XMLService / TCPUDPDeal / TAPromotion 【强制】常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。 正例： MAX_STOCK_COUNT 反例： MAX_COUNT 【强制】抽象类命名使用Abstract或Base开头；异常类命名使用Exception结尾；测试类命名以它要测试的类的名称开始，以Test结尾。 【强制】POJO类中的任何布尔类型的变量，都不要加is，否则部分框架解析会引起序列化错误。 反例：定义为基本数据类型boolean isSuccess；的属性，它的方法也是isSuccess()，RPC框架在反向解析的时候，“以为”对应的属性名称是 success，导致属性获取不到，进而抛出异常。 【强制】杜绝完全不规范的缩写，避免望文不知义。 反例：&lt;某业务代码&gt;AbstractClass“缩写”命名成AbsClass；condition“缩写”命名成 condi，此类随意缩写严重降低了代码的可阅读性。 【推荐】接口类中的方法和属性不要加任何修饰符号（public 也不要加），保持代码的简洁性，并加上有效的javadoc注释。尽量不要在接口里定义变量，如果一定要定义变量，肯定是与接口方法相关，并且是整个应用的基础常量。 正例：接口方法签名：void f(); 接口基础常量表示：String COMPANY = “alibaba”; 反例：接口方法定义：public abstract void f(); 说明：JDK8中接口允许有默认实现，那么这个default方法，是对所有实现类都有价值的默认实现。 【参考】各层命名规约： A) Service/DAO层方法命名规约 1） 获取单个对象的方法用get做前缀。 2） 获取多个对象的方法用list做前缀。 3） 获取统计值的方法用count做前缀。 4） 插入的方法用save（推荐）或insert做前缀。 5） 删除的方法用remove（推荐）或delete做前缀。 6） 修改的方法用update做前缀。 B) 领域模型命名规约 1） 数据对象：xxxDO，xxx即为数据表名。 2） 数据传输对象：xxxDTO，xxx为业务领域相关的名称。 3） 展示对象：xxxVO，xxx一般为网页名称。 4） POJO是DO/DTO/BO/VO的统称，禁止命名成xxxPOJO。","text":"Java开发手册( 版本号 制作团队 更新日期 备注 1.0.0 阿里巴巴集团技术部 2016.12.7 首次公开 编程规约(一) 命名规约 【强制】类名使用UpperCamelCase风格，必须遵从驼峰形式，但以下情形例外：（领域模型的相关命名）DO / DTO / VO / DAO等。 正例：MarcoPolo / UserDO / XmlService / TcpUdpDeal / TaPromotion 反例：macroPolo / UserDo / XMLService / TCPUDPDeal / TAPromotion 【强制】常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。 正例： MAX_STOCK_COUNT 反例： MAX_COUNT 【强制】抽象类命名使用Abstract或Base开头；异常类命名使用Exception结尾；测试类命名以它要测试的类的名称开始，以Test结尾。 【强制】POJO类中的任何布尔类型的变量，都不要加is，否则部分框架解析会引起序列化错误。 反例：定义为基本数据类型boolean isSuccess；的属性，它的方法也是isSuccess()，RPC框架在反向解析的时候，“以为”对应的属性名称是 success，导致属性获取不到，进而抛出异常。 【强制】杜绝完全不规范的缩写，避免望文不知义。 反例：&lt;某业务代码&gt;AbstractClass“缩写”命名成AbsClass；condition“缩写”命名成 condi，此类随意缩写严重降低了代码的可阅读性。 【推荐】接口类中的方法和属性不要加任何修饰符号（public 也不要加），保持代码的简洁性，并加上有效的javadoc注释。尽量不要在接口里定义变量，如果一定要定义变量，肯定是与接口方法相关，并且是整个应用的基础常量。 正例：接口方法签名：void f(); 接口基础常量表示：String COMPANY = “alibaba”; 反例：接口方法定义：public abstract void f(); 说明：JDK8中接口允许有默认实现，那么这个default方法，是对所有实现类都有价值的默认实现。 【参考】各层命名规约： A) Service/DAO层方法命名规约 1） 获取单个对象的方法用get做前缀。 2） 获取多个对象的方法用list做前缀。 3） 获取统计值的方法用count做前缀。 4） 插入的方法用save（推荐）或insert做前缀。 5） 删除的方法用remove（推荐）或delete做前缀。 6） 修改的方法用update做前缀。 B) 领域模型命名规约 1） 数据对象：xxxDO，xxx即为数据表名。 2） 数据传输对象：xxxDTO，xxx为业务领域相关的名称。 3） 展示对象：xxxVO，xxx一般为网页名称。 4） POJO是DO/DTO/BO/VO的统称，禁止命名成xxxPOJO。 (二) 常量定义 【强制】不允许出现任何魔法值（即未经定义的常量）直接出现在代码中。 反例： String key=”Id#taobao_”+tradeId； cache.put(key, value); 【强制】long或者Long初始赋值时，必须使用大写的L，不能是小写的l，小写容易跟数字1混淆，造成误解。 说明：Long a = 2l; 写的是数字的21，还是Long型的2? 【推荐】不要使用一个常量类维护所有常量，应该按常量功能进行归类，分开维护。如：缓存相关的常量放在类：CacheConsts下；系统配置相关的常量放在类：ConfigConsts下。 说明：大而全的常量类，非得ctrl+f才定位到修改的常量，不利于理解，也不利于维护。 (三) 格式规约 【强制】大括号的使用约定。如果是大括号内为空，则简洁地写成{}即可，不需要换行；如果是非空代码块则： 1） 左大括号前不换行。 2） 左大括号后换行。 3） 右大括号前换行。 4） 右大括号后还有else等代码则不换行；表示终止右大括号后必须换行。 【强制】单行字符数限制不超过120个，超出需要换行，换行时，遵循如下原则： 1） 换行时相对上一行缩进4个空格。 2） 运算符与下文一起换行。 3） 方法调用的点符号与下文一起换行。 4） 在多个参数超长，逗号后进行换行。 5） 在括号前不要换行，见反例。 正例： StringBuffer sb = new StringBuffer(); //超过120个字符的情况下，换行缩进4个空格，并且方法前的点符号一起换行 sb.append(“zi”).append(“xin”)… .append(“huang”); 反例： StringBuffer sb = new StringBuffer(); //超过120个字符的情况下，不要在括号前换行 sb.append(“zi”).append(“xin”)…append (“huang”); //参数很多的方法调用也超过120个字符，逗号后才是换行处 method(args1, args2, args3, … , argsX); 【推荐】方法体内的执行语句组、变量的定义语句组、不同的业务逻辑之间或者不同的语义之间插入一个空行。相同业务逻辑和语义之间不需要插入空行。 说明：没有必要插入多行空格进行隔开。(四) OOP规约 【强制】所有的覆写方法，必须加@Override注解。 反例：getObject()与get0bject()的问题。一个是字母的O，一个是数字的0，加@Override可以准确判断是否覆盖成功。另外，如果在抽象类中对方法签名进行修改，其实现类会马上编译报错。 【强制】对外暴露的接口签名，原则上不允许修改方法签名，避免对接口调用方产生影响。接口过时必须加@Deprecated注解，并清晰地说明采用的新接口或者新服务是什么。 【强制】不能使用过时的类或方法。 说明：java.net.URLDecoder 中的方法decode(String encodeStr) 这个方法已经过时，应该使用双参数decode(String source, String encode)。接口提供方既然明确是过时接口，那么有义务同时提供新的接口；作为调用方来说，有义务去考证过时方法的新实现是什么。 【强制】Object的equals方法容易抛空指针异常，应使用常量或确定有值的对象来调用equals。 正例： “test”.equals(object); 反例： object.equals(“test”); 说明：推荐使用java.util.Objects#equals （JDK7引入的工具类） 【强制】所有的相同类型的包装类对象之间值的比较，全部使用equals方法比较。 说明：对于Integer var=?在-128至127之间的赋值，Integer对象是在IntegerCache.cache产生，会复用已有对象，这个区间内的Integer值可以直接使用==进行判断，但是这个区间之外的所有数据，都会在堆上产生，并不会复用已有对象，这是一个大坑，推荐使用equals方法进行判断。 【强制】关于基本数据类型与包装数据类型的使用标准如下： 1） 所有的POJO类属性必须使用包装数据类型。 2） RPC方法的返回值和参数必须使用包装数据类型。 3） 所有的局部变量推荐使用基本数据类型。 说明：POJO类属性没有初值是提醒使用者在需要使用时，必须自己显式地进行赋值，任何NPE问题，或者入库检查，都由使用者来保证。 正例：数据库的查询结果可能是null，因为自动拆箱，用基本数据类型接收有NPE风险。 反例：某业务的交易报表上显示成交总额涨跌情况，即正负x%，x为基本数据类型，调用的RPC服务，调用不成功时，返回的是默认值，页面显示：0%，这是不合理的，应该显示成中划线-。所以包装数据类型的null值，能够表示额外的信息，如：远程调用失败，异常退出。 【强制】构造方法里面禁止加入任何业务逻辑，如果有初始化逻辑，请放在init方法中。 【推荐】 类内方法定义顺序依次是：公有方法或保护方法 &gt; 私有方法 &gt; getter/setter方法。 说明：公有方法是类的调用者和维护者最关心的方法，首屏展示最好；保护方法虽然只是子类关心，也可能是“模板设计模式”下的核心方法；而私有方法外部一般不需要特别关心，是一个黑盒实现；因为方法信息价值较低，所有Service和DAO的getter/setter方法放在类体最后。 【推荐】慎用Object的clone方法来拷贝对象。 说明：对象的clone方法默认是浅拷贝，若想实现深拷贝需要重写clone方法实现属性对象的拷贝。 (五) 集合处理 【强制】Map/Set的key为自定义对象时，必须重写hashCode和equals。 正例：String重写了hashCode和equals方法，所以我们可以非常愉快地使用String对象作为key来使用。 【强制】ArrayList的subList结果不可强转成ArrayList，否则会抛出ClassCastException异常：java.util.RandomAccessSubList cannot be cast to java.util.ArrayList ; 说明：subList 返回的是 ArrayList 的内部类 SubList，并不是 ArrayList ，而是 ArrayList 的一个视图，对于SubList子列表的所有操作最终会反映到原列表上。 【强制】在subList场景中，高度注意对原集合元素个数的修改，会导致子列表的遍历、增加、删除均产生ConcurrentModificationException 异常。 【强制】使用工具类Arrays.asList()把数组转换成集合时，不能使用其修改集合相关的方法，它的add/remove/clear方法会抛出UnsupportedOperationException异常。 说明：asList的返回对象是一个Arrays内部类，并没有实现集合的修改方法。Arrays.asList体现的是适配器模式，只是转换接口，后台的数据仍是数组。 String[] str = new String[] { “a”, “b” }; List list = Arrays.asList(str); 第一种情况：list.add(“c”); 运行时异常。 第二种情况：str[0]= “gujin”; 那么list.get(0)也会随之修改。 【强制】不要在foreach循环里进行元素的remove/add操作。remove元素请使用Iterator方式，如果并发操作，需要对Iterator对象加锁。反例： 12List&lt;String&gt; a = new ArrayList&lt;String&gt;();a.add(\"1\"); a.add(\"2\"); for (String temp : a) &#123; if(\"1\".equals(temp))&#123; a.remove(temp); &#125; &#125; 说明：这个例子的执行结果会出乎大家的意料，那么试一下把“1”换成“2”，会是同样的结果吗？正例：12Iterator&lt;String&gt; it = a.iterator(); while(it.hasNext())&#123;String temp = it.next(); if(删除元素的条件)&#123; it.remove(); &#125; &#125; 【强制】在JDK7版本以上，Comparator要满足自反性，传递性，对称性，不然Arrays.sort，Collections.sort会报IllegalArgumentException异常。 说明： 1） 自反性：x，y的比较结果和y，x的比较结果相反。 2） 传递性：x&gt;y,y&gt;z,则x&gt;z。 3） 对称性：x=y,则x,z比较结果和y，z比较结果相同。 反例：下例中没有处理相等的情况，实际使用中可能会出现异常： 1new Comparator&lt;Student&gt;() &#123; @Override public int compare(Student o1, Student o2) &#123; return o1.getId() &gt; o2.getId() ? 1 : -1; &#125; &#125; 【推荐】集合初始化时，尽量指定集合初始值大小。 说明：ArrayList尽量使用ArrayList(int initialCapacity) 初始化。 【推荐】使用entrySet遍历Map类集合KV，而不是keySet方式进行遍历。 说明：keySet其实是遍历了2次，一次是转为Iterator对象，另一次是从hashMap中取出key所对应的value。而entrySet只是遍历了一次就把key和value都放到了entry中，效率更高。如果是JDK8，使用Map.foreach方法。 正例：values()返回的是V值集合，是一个list集合对象；keySet()返回的是K值集合，是一个Set集合对象；entrySet()返回的是K-V值组合集合。 【推荐】高度注意Map类集合K/V能不能存储null值的情况 集合类 Key Value Super 说明 Hashtable 不允许为null 不允许为null Dictionary 线程安全 ConcurrentHashMap 不允许为null 不允许为null AbstractMap 线程局部安全 TreeMap 不允许为null 允许为null AbstractMap 线程不安全 HashMap 允许为null 允许为null AbstractMap 线程不安全 (六) 并发处理 【强制】获取单例对象要线程安全。在单例对象里面做操作也要保证线程安全。 说明：资源驱动类、工具类、单例工厂类都需要注意。 【强制】线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。 说明：使用线程池的好处是减少在创建和销毁线程上所花的时间以及系统资源的开销，解决资源不足的问题。如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。 【强制】SimpleDateFormat 是线程不安全的类，一般不要定义为static变量，如果定义为static，必须加锁，或者使用DateUtils工具类。 正例：注意线程安全，使用DateUtils。亦推荐如下处理：1private static final ThreadLocal&lt;DateFormat&gt; df = new ThreadLocal&lt;DateFormat&gt;() &#123; @Override protected DateFormat initialValue() &#123; return new SimpleDateFormat(\"yyyy-MM-dd\"); &#125; &#125;; 说明：如果是JDK8的应用，可以使用instant代替Date，Localdatetime代替Calendar，Datetimeformatter代替Simpledateformatter，官方 给出的解释：simple beautiful strong immutable thread-safe。 【强制】高并发时，同步调用应该去考量锁的性能损耗。能用无锁数据结构，就不要用锁；能锁区块，就不要锁整个方法体；能用对象锁，就不要用类锁。 【强制】对多个资源、数据库表、对象同时加锁时，需要保持一致的加锁顺序，否则可能会造成死锁。 说明：线程一需要对表A、B、C依次全部加锁后才可以进行更新操作，那么线程二的加锁顺序也必须是A、B、C，否则可能出现死锁。 【强制】并发修改同一记录时，避免更新丢失，要么在应用层加锁，要么在缓存加锁，要么在数据库层使用乐观锁，使用version作为更新依据。说明：如果每次访问冲突概率小于20%，推荐使用乐观锁，否则使用悲观锁。乐观锁的重试次数不得小于3次。 【强制】多线程并行处理定时任务时，Timer运行多个TimeTask时，只要其中之一没有捕获抛出的异常，其它任务便会自动终止运行，使用ScheduledExecutorService则没有这个问题。 【强制】线程池不允许使用Executors去创建，而是通过ThreadPoolExecutor的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。 说明：Executors各个方法的弊端： 1）newFixedThreadPool和newSingleThreadExecutor: 主要问题是堆积的请求处理队列可能会耗费非常大的内存，甚至OOM。 2）newCachedThreadPool和newScheduledThreadPool: 主要问题是线程数最大数是Integer.MAX_VALUE，可能会创建数量非常多的线程，甚至OOM。 【强制】创建线程或线程池时请指定有意义的线程名称，方便出错时回溯。正例： 1public class TimerTaskThread extends Thread &#123; public TimerTaskThread()&#123; super.setName(\"TimerTaskThread\"); … &#125; 【推荐】使用CountDownLatch进行异步转同步操作，每个线程退出前必须调用countDown方法，线程执行代码注意catch异常，确保countDown方法可以执行，避免主线程无法执行至countDown方法，直到超时才返回结果。 说明：注意，子线程抛出异常堆栈，不能在主线程try-catch到。 【推荐】避免Random实例被多线程使用，虽然共享该实例是线程安全的，但会因竞争同一seed 导致的性能下降。 说明：Random实例包括java.util.Random 的实例或者 Math.random()实例。 正例：在JDK7之后，可以直接使用API ThreadLocalRandom，在 JDK7之前，可以做到每个线程一个实例。 【参考】volatile解决多线程内存不可见问题。对于一写多读，是可以解决变量同步问题，但是如果多写，同样无法解决线程安全问题。如果想取回count++数据，使用如下类实现：AtomicInteger count = new AtomicInteger(); count.addAndGet(1); count++操作如果是JDK8，推荐使用LongAdder对象，比AtomicLong性能更好（减少乐观锁的重试次数）。 【参考】ThreadLocal无法解决共享对象的更新问题，ThreadLocal对象建议使用static修饰。这个变量是针对一个线程内所有操作共有的，所以设置为静态变量，所有此类实例共享此静态变量 ，也就是说在类第一次被使用时装载，只分配一块存储空间，所有此类的对象(只要是这个线程内定义的)都可以操控这个变量。 (七) 控制语句 【强制】在if/else/for/while/do语句中必须使用大括号，即使只有一行代码，避免使用下面的形式：if (condition) statements; 【推荐】推荐尽量少用else， if-else的方式可以改写成： if(condition){ … return obj; } // 接着写else的业务逻辑代码; 说明：如果使用要if-else if-else方式表达逻辑，【强制】请勿超过3层，超过请使用状态设计模式。 (八) 注释规约 【强制】类、类属性、类方法的注释必须使用javadoc规范，使用/*内容/格式，不得使用//xxx方式。 说明：在IDE编辑窗口中，javadoc方式会提示相关注释，生成javadoc可以正确输出相应注释；在IDE中，工程调用方法时，不进入方法即可悬浮提示方法、参数、返回值的意义，提高阅读效率。 【强制】所有的抽象方法（包括接口中的方法）必须要用javadoc注释、除了返回值、参数、异常说明外，还必须指出该方法做什么事情，实现什么功能。 说明：如有实现和调用注意事项，请一并说明。 【参考】对于注释的要求：第一、能够准确反应设计思想和代码逻辑；第二、能够描述业务含义，使别的程序员能够迅速了解到代码背后的信息。完全没有注释的大段代码对于阅读者形同天书，注释是给自己看的，即使隔很长时间，也能清晰理解当时的思路；注释也是给继任者看的，使其能够快速接替自己的工作。 (九) 其它 【强制】在使用正则表达式时，利用好其预编译功能，可以有效加快正则匹配速度。 说明：不要在方法体内定义：Pattern pattern = Pattern.compile(规则); 【强制】避免用Apache Beanutils进行属性的copy。 说明：Apache BeanUtils性能较差，可以使用其他方案比如Spring BeanUtils, Cglib BeanCopier。 【强制】注意 Math.random() 这个方法返回是double类型，注意取值范围 0≤x&lt;1（能够取到零值，注意除零异常），如果想获取整数类型的随机数，不要将x放大10的若干倍然后取整，直接使用Random对象的nextInt或者nextLong方法。 【强制】获取当前毫秒数：System.currentTimeMillis(); 而不是new Date().getTime(); 说明：如果想获取更加精确的纳秒级时间值，用System.nanoTime。在JDK8中，针对统计时间等场景，推荐使用Instant类。 【推荐】任何数据结构的使用都应限制大小。 说明：这点很难完全做到，但很多次的故障都是因为数据结构自增长，结果造成内存被吃光。 【推荐】对于“明确停止使用的代码和配置”，如方法、变量、类、配置文件、动态配置属性等要坚决从程序中清理出去，避免造成过多垃圾。清理这类垃圾代码是技术气场，不要有这样的观念：“不做不错，多做多错”。 二、异常日志(一) 异常处理 【强制】不要捕获Java类库中定义的继承自RuntimeException的运行时异常类，如：IndexOutOfBoundsException / NullPointerException，这类异常由程序员预检查来规避，保证程序健壮性。 【强制】异常不要用来做流程控制，条件控制，因为异常的处理效率比条件分支低。 【强制】对大段代码进行try-catch，这是不负责任的表现。catch时请分清稳定代码和非稳定代码，稳定代码指的是无论如何不会出错的代码。对于非稳定代码的catch尽可能进行区分异常类型，再做对应的异常处理。 【强制】捕获异常是为了处理它，不要捕获了却什么都不处理而抛弃之，如果不想处理它，请将该异常抛给它的调用者。最外层的业务使用者，必须处理异常，将其转化为用户可以理解的内容。 【强制】finally块必须对资源对象、流对象进行关闭，有异常也要做try-catch。 说明：如果JDK7，可以使用try-with-resources方法。 【强制】不能在finally块中使用return，finally块中的return返回后方法结束执行，不会再执行try块中的return语句。 【推荐】方法的返回值可以为null，不强制返回空集合，或者空对象等，必须添加注释充分说明什么情况下会返回null值。调用方需要进行null判断防止NPE问题。 说明：本规约明确防止NPE是调用者的责任。即使被调用方法返回空集合或者空对象，对调用者来说，也并非高枕无忧，必须考虑到远程调用失败，运行时异常等场景返回null的情况。 【推荐】防止NPE，是程序员的基本修养，注意NPE产生的场景：1） 返回类型为包装数据类型，有可能是null，返回int值时注意判空。2） 数据库的查询结果可能为null。 3） 集合里的元素即使isNotEmpty，取出的数据元素也可能为null。 4） 远程调用返回对象，一律要求进行NPE判断。 5） 对于Session中获取的数据，建议NPE检查，避免空指针。 6） 级联调用obj.getA().getB().getC()；一连串调用，易产生NPE。 【推荐】在代码中使用“抛异常”还是“返回错误码”，对于公司外的http/api开放接口必须使用“错误码”；而应用内部推荐异常抛出；跨应用间RPC调用优先考虑使用Result方式，封装isSuccess、“错误码”、“错误简短信息”。 说明：关于RPC方法返回方式使用Result方式的理由： 1）使用抛异常返回方式，调用方如果没有捕获到就会产生运行时错误。 2）如果不加栈信息，只是new自定义异常，加入自己的理解的error message，对于调用端解决问题的帮助不会太多。如果加了栈信息，在频繁调用出错的情况下，数据序列化和传输的性能损耗也是问题。 【推荐】定义时区分unchecked / checked 异常，避免直接使用RuntimeException抛出，更不允许抛出Exception或者Throwable，应使用有业务含义的自定义异常。推荐业界已定义过的自定义异常，如：DaoException / ServiceException等。 (二) 日志规约 【强制】应用中不可直接使用日志系统（Log4j、Logback）中的API，而应依赖使用日志框架SLF4J中的API，使用门面模式的日志框架，有利于维护和各个类的日志处理方式统一。 import org.slf4j.Logger; import org.slf4j.LoggerFactory; private static final Logger logger = LoggerFactory.getLogger(Abc.class); 【强制】对trace/debug/info级别的日志输出，必须使用条件输出形式或者使用占位符的方式。 说明：logger.debug(“Processing trade with id: “ + id + “ symbol: “ + symbol); 如果日志级别是warn，上述日志不会打印，但是会执行字符串拼接操作，如果symbol是对象，会执行toString()方法，浪费了系统资源，执行了上述操作，最终日志却没有打印。正例：（条件）1if (logger.isDebugEnabled()) &#123; logger.debug(\"Processing trade with id: \" + id + \" symbol: \" + symbol); &#125; 正例：（占位符）1logger.debug(\"Processing trade with id: &#123;&#125; and symbol : &#123;&#125; \", id, symbol); 【强制】避免重复打印日志，浪费磁盘空间，务必在log4j.xml中设置additivity=false。 正例： 【强制】异常信息应该包括两类信息：案发现场信息和异常堆栈信息。如果不处理，那么往上抛。 正例：logger.error(各类参数或者对象toString + “_” + e.getMessage(), e); 三、MYSQL规约(一) 建表规约 【强制】表达是与否概念的字段，必须使用is_xxx的方式命名，数据类型是unsigned tinyint（ 1表示是，0表示否），此规则同样适用于odps建表。 说明：任何字段如果为非负数，必须是unsigned。 【强制】唯一索引名为uk字段名；普通索引名则为idx字段名。 说明：uk 即 unique key；idx 即index的简称。 【强制】小数类型为decimal，禁止使用float和double。 说明：float和double在存储的时候，存在精度损失的问题，很可能在值的比较时，得到不正确的结果。如果存储的数据范围超过decimal的范围，建议将数据拆成整数和小数分开存储。 【强制】如果存储的字符串长度几乎相等，使用CHAR定长字符串类型。 【强制】varchar是可变长字符串，不预先分配存储空间，长度不要超过5000，如果存储长度大于此值，定义字段类型为TEXT，独立出来一张表，用主键来对应，避免影响其它字段索引效率。 【强制】表必备三字段：id, gmt_create, gmt_modified。 说明：其中id必为主键，类型为unsigned bigint、单表时自增、步长为1；分表时改为从TDDL Sequence取值，确保分表之间的全局唯一。gmt_create, gmt_modified的类型均为date_time类型。 【推荐】字段允许适当冗余，以提高性能，但是必须考虑数据同步的情况。冗余字段应遵循： 1）不是频繁修改的字段。 2）不是varchar超长字段，更不能是text字段。 正例：各业务线经常冗余存储商品名称，避免查询时需要调用IC服务获取。 【推荐】单表行数超过500万行或者单表容量超过2GB，才推荐进行分库分表。 说明：如果预计三年后的数据量根本达不到这个级别，请不要在创建表时就分库分表。 反例：某业务三年总数据量才2万行，却分成1024张表，问：你为什么这么设计？答：分1024张表，不是标配吗？ (二) 索引规约 【强制】业务上具有唯一特性的字段，即使是组合字段，也必须建成唯一索引。 说明：不要以为唯一索引影响了insert速度，这个速度损耗可以忽略，但提高查找速度是明显的；另外，即使在应用层做了非常完善的校验和控制，只要没有唯一索引，根据墨菲定律，必然有脏数据产生。 【强制】超过三个表禁止join。需要join的字段，数据类型保持绝对一致；多表关联查询时，保证被关联的字段需要有索引。 说明：即使双表join也要注意表索引、SQL性能。 【强制】在varchar字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据实际文本区分度决定索引长度。 说明：索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为20的索引，区分度会高达90%以上，可以使用count(distinct left(列名, 索引长度))/count(*)的区分度来确定。 【强制】页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。 说明：索引文件具有B-Tree的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索引。 【推荐】如果有order by的场景，请注意利用索引的有序性。order by 最后的字段是组合索引的一部分，并且放在索引组合顺序的最后，避免出现file_sort的情况，影响查询性能。 正例：where a=? and b=? order by c; 索引：a_b_c 反例：索引中有范围查找，那么索引有序性无法利用，如：WHERE a&gt;10 ORDER BY b; 索引a_b无法排序。 【推荐】利用覆盖索引来进行查询操作，来避免回表操作。 说明：如果一本书需要知道第11章是什么标题，会翻开第11章对应的那一页吗？目录浏览一下就好，这个目录就是起到覆盖索引的作用。 正例：IDB能够建立索引的种类：主键索引、唯一索引、普通索引，而覆盖索引是一种查询的一种效果，用explain的结果，extra列会出现：using index. 【推荐】利用延迟关联或者子查询优化超多分页场景。 说明：MySQL并不是跳过offset行，而是取offset+N行，然后返回放弃前offset行，返回N行，那当offset特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过特定阈值的页数进行SQL改写。 正例：先快速定位需要获取的id段，然后再关联： SELECT a.* FROM 表1 a, (select id from 表1 where 条件 LIMIT 100000,20 ) b where a.id=b.id 【推荐】 SQL性能优化的目标：至少要达到 range 级别，要求是ref级别，如果可以是consts最好。 说明： 1）consts 单表中最多只有一个匹配行（主键或者唯一索引），在优化阶段即可读取到数据。 2）ref 指的是使用普通的索引。（normal index） 3）range 对索引进范围检索。 【推荐】建组合索引的时候，区分度最高的在最左边。 正例：如果where a=? and b=? ，a列的几乎接近于唯一值，那么只需要单建idx_a索引即可。说明：存在非等号和等号混合判断条件时，在建索引时，请把等号条件的列前置。如：where a&gt;? and b=? 那么即使a的区分度更高，也必须把b放在索引的最前列。 (三) SQL规约 【强制】不要使用count(列名)或count(常量)来替代count()，count()就是SQL92定义的标准统计行数的语法，跟数据库无关，跟NULL和非NULL无关。说明：count(*)会统计值为NULL的行，而count(列名)不会统计此列为NULL值的行。 【强制】count(distinct col) 计算该列除NULL之外的不重复数量。注意 count(distinct col1, col2) 如果其中一列全为NULL，那么即使另一列有不同的值，也返回为0。 【强制】当某一列的值全是NULL时，count(col)的返回结果为0，但sum(col)的返回结果为NULL，因此使用sum()时需注意NPE问题。 正例：可以使用如下方式来避免sum的NPE问题：SELECT IF(ISNULL(SUM(g)),0,SUM(g)) FROM table; 【强制】使用ISNULL()来判断是否为NULL值。注意：NULL与任何值的直接比较都为NULL。 说明： 1） NULL&lt;&gt;NULL的返回结果是NULL，不是false。 2） NULL=NULL的返回结果是NULL，不是true。 3） NULL&lt;&gt;1的返回结果是NULL，而不是true。 【强制】在代码中写分页查询逻辑时，若count为0应直接返回，避免执行后面的分页语句。 【强制】不得使用外键与级联，一切外键概念必须在应用层解决。 说明：（概念解释）学生表中的student_id是主键，那么成绩表中的student_id则为外键。如果更新学生表中的student_id，同时触发成绩表中的student_id更新，则为级联更新。外键与级联更新适用于单机低并发，不适合分布式、高并发集群；级联更新是强阻塞，存在数据库更新风暴的风险；外键影响数据库的插入速度。 【强制】禁止使用存储过程，存储过程难以调试和扩展，更没有移植性。 【强制】IDB数据订正时，删除和修改记录时，要先select，避免出现误删除，确认无误才能提交执行。 【推荐】in操作能避免则避免，若实在避免不了，需要仔细评估in后边的集合元素数量，控制在1000个之内。 【参考】TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少，但TRUNCATE无事务且不触发trigger，有可能造成事故，故不建议在开发代码中使用此语句。 说明：TRUNCATE TABLE 在功能上与不带 WHERE 子句的 DELETE 语句相同。 (四) ORM规约 【强制】在表查询中，一律不要使用 * 作为查询的字段列表，需要哪些字段必须明确写明。 说明：1）增加查询分析器解析成本。2）增减字段容易与resultMap配置不一致。 【强制】POJO类的boolean属性不能加is，而数据库字段必须加is_，要求在resultMap中进行字段与属性之间的映射 【强制】xml配置中参数注意使用：#{}，#param# 不要使用${} 此种方式容易出现SQL注入。 【强制】iBATIS自带的queryForList(String statementName,int start,int size)不推荐使用。 说明：其实现方式是在数据库取到statementName对应的SQL语句的所有记录，再通过subList取start,size的子集合，线上因为这个原因曾经出现过OOM。 正例：在sqlmap.xml中引入 #start#, #size# Map map = new HashMap(); map.put(“start”, start); map.put(“size”, size); 【强制】不允许直接拿HashMap与HashTable作为查询结果集的输出。 反例：某同学为避免写一个，直接使用HashTable来接收数据库返回结果，结果出现日常是把bigint转成Long值，而线上由于数据库版本不一样，解析成BigInteger，导致线上问题。 【强制】更新数据表记录时，必须同时更新记录对应的gmt_modified字段值为当前时间。 【参考】@Transactional事务不要滥用。事务会影响数据库的QPS，另外使用事务的地方需要考虑各方面的回滚方案，包括缓存回滚、搜索引擎回滚、消息补偿、统计修正等。 ##四、工程规约 (一) 应用分层 【参考】（分层异常处理规约）在DAO层，产生的异常类型有很多，无法用细粒度异常进行catch，使用catch(Exception e)方式，并throw new DaoException(e)，不需要打印日志，因为日志在Manager/Service层一定需要捕获并打到日志文件中去，如果同台服务器再打日志，浪费性能和存储。在Service层出现异常时，必须记录日志信息到磁盘，尽可能带上参数信息，相当于保护案发现场。如果Manager层与Service同机部署，日志方式与DAO层处理一致，如果是单独部署，则采用与Service一致的处理方式。Web层绝不应该继续往上抛异常，因为已经处于顶层，无继续处理异常的方式，如果意识到这个异常将导致页面无法正常渲染，那么就应该直接跳转到友好错误页面，尽量加上友好的错误提示信息。开放接口层要将异常处理成错误码和错误信息方式返回。 【参考】分层领域模型规约： DO（Data Object）：与数据库表结构一一对应，通过DAO层向上传输数据源对象。 DTO（Data Transfer Object）：数据传输对象，Service和Manager向外传输的对象。 BO（Business Object）：业务对象。可以由Service层输出的封装业务逻辑的对象。 QUERY：数据查询对象，各层接收上层的查询请求。注：超过2个参数的查询封装，禁止使用Map类来传输。  VO（View Object）：显示层对象，通常是Web向模板渲染引擎层传输的对象。(二) 二方库规约 【推荐】工具类二方库已经提供的，尽量不要在本应用中编程实现。  json操作： fastjson md5操作：commons-codec  工具集合：Guava包  数组操作：ArrayUtils（org.apache.commons.lang3.ArrayUtils）  集合操作：CollectionUtils(org.apache.commons.collections4.CollectionUtils)  除上面以外还有NumberUtils、DateFormatUtils、DateUtils等优先使用org.apache.commons.lang3这个包下的，不要使用org.apache.commons.lang包下面的。原因是commons.lang这个包是从JDK1.2开始支持的所以很多1.5/1.6的特性是不支持的，例如：泛型。 【推荐】所有pom文件中的依赖声明放在语句块中，所有版本仲裁放在语句块中。 说明：里只是声明版本，并不实现引入，因此子项目需要显式的声明依赖，version和scope都读取自父pom。而所有声明在主pom的里的依赖都会自动引入，并默认被所有的子项目继承 (三) 服务器规约 【推荐】高并发服务器建议调小TCP协议的time_wait超时时间。 说明：操作系统默认240秒后，才会关闭处于time_wait状态的连接，在高并发访问下，服务器端会因为处于time_wait的连接数太多，可能无法建立新的连接，所以需要在服务器上调小此等待值。 正例：在linux服务器上请通过变更/etc/sysctl.conf文件去修改该缺省值（秒）： net.ipv4.tcp_fin_timeout = 30 【推荐】调大服务器所支持的最大文件句柄数（File Descriptor，简写为fd）。 说明：主流操作系统的设计是将TCP/UDP连接采用与文件一样的方式去管理，即一个连接对应于一个fd。主流的linux服务器默认所支持最大fd数量为1024，当并发连接数很大时很容易因为fd不足而出现“open too many files”错误，导致新的连接无法建立。 建议将linux服务器所支持的最大句柄数调高数倍（与服务器的内存数量相关）。 【推荐】给JVM设置-XX:+HeapDumpOnOutOfMemoryError参数，让JVM碰到OOM场景时输出dump信息。 【参考】服务器内部重定向必须使用forward；外部重定向地址必须使用URL Broker生成，否则因线上采用HTTPS协议而导致浏览器提示“不安全”。此外，还会带来URL维护不一致的问题。 五、安全规约 【强制】可被用户直接访问的功能必须进行权限控制校验。 说明：防止没有做权限控制就可随意访问、操作别人的数据，比如查看、修改别人的订单。 【强制】用户敏感数据禁止直接展示，必须对展示数据脱敏。 说明：支付宝中查看个人手机号码会显示成:158**9119，隐藏中间4位，防止隐私泄露。 【强制】用户输入的SQL参数严格使用参数绑定或者METADATA字段值限定，防止SQL注入，禁止字符串拼接SQL访问数据库。 【强制】用户请求传入的任何参数必须做有效性验证。 说明：忽略参数校验可能导致：  page size过大导致内存溢出  恶意order by导致数据库慢查询  正则输入源串拒绝服务ReDOS  任意重定向  SQL注入  Shell注入  反序列化注入 【强制】禁止向HTML页面输出未经安全过滤或未正确转义的用户数据。 【强制】表单、AJAX提交必须执行CSRF安全过滤。 说明：CSRF(Cross-site request forgery)跨站请求伪造是一类常见编程漏洞。对于存在CSRF漏洞的应用/网站，攻击者可以事先构造好URL，只要受害者用户一访问，后台便在用户不知情情况下对数据库中用户参数进行相应修改。 【强制】URL外部重定向传入的目标地址必须执行白名单过滤。 正例： 1try &#123; if (com.alibaba.fasttext.sec.url.CheckSafeUrl .getDefaultInstance().inWhiteList(targetUrl))&#123; response.sendRedirect(targetUrl); &#125; &#125; catch (IOException e) &#123; logger.error(\"Check returnURL error! targetURL=\" + targetURL, e); throw e; 【强制】Web应用必须正确配置Robots文件，非SEO URL必须配置为禁止爬虫访问。 User-agent: * Disallow: / 【强制】在使用平台资源，譬如短信、邮件、电话、下单、支付，必须实现正确的防重放限制，如数量限制、疲劳度控制、验证码校验，避免被滥刷、资损。 说明：如注册时发送验证码到手机，如果没有限制次数和频率，那么可以利用此功能骚扰到其它用户，并造成短信平台资源浪费。 【推荐】发贴、评论、发送即时消息等用户生成内容的场景必须实现防刷、文本内容违禁词过滤等风控策略。","categories":[{"name":"Java","slug":"Java","permalink":"http://zhangliting.github.io/categories/Java/"}],"tags":[{"name":"阿里巴巴","slug":"阿里巴巴","permalink":"http://zhangliting.github.io/tags/阿里巴巴/"}]}]}